

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pyfurnace.design.core.motif &mdash; pyFuRNAce 0.0.7 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css?v=76b2166b" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=bbaf98b3"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../../_static/copybutton.js?v=f281be69"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            pyFuRNAce
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../features.html#installation">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../features.html#web-application">Web Application</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../features.html#using-the-python-api">Using the Python API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../features.html#citation">Citation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../features.html#license">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../features.html#acknowledgements">Acknowledgements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api.html">Script API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../examples.html">Examples</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">pyFuRNAce</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pyfurnace.design.core.motif</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pyfurnace.design.core.motif</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">copysign</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Callable</span>

<span class="c1"># OAT IMPORTS</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">oxDNA_analysis_tools.external_force_utils.force_reader</span> <span class="kn">import</span> <span class="n">write_force_file</span>
    <span class="kn">from</span> <span class="nn">oxDNA_analysis_tools.external_force_utils.forces</span> <span class="kn">import</span> <span class="n">mutual_trap</span>
    <span class="kn">from</span> <span class="nn">oxDNA_analysis_tools.UTILS.RyeReader</span> <span class="kn">import</span> <span class="p">(</span><span class="n">get_confs</span><span class="p">,</span>
                                                      <span class="n">describe</span><span class="p">,</span>
                                                      <span class="n">strand_describe</span><span class="p">,</span>
                                                      <span class="n">inbox</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">oxDNA_analysis_tools.oxDNA_PDB</span> <span class="kn">import</span> <span class="n">oxDNA_PDB</span>
    <span class="n">oat_installed</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">oat_installed</span> <span class="o">=</span> <span class="kc">False</span>

<span class="c1"># pyFuRNAce IMPORTS</span>
<span class="kn">from</span> <span class="nn">.symbols</span> <span class="kn">import</span> <span class="n">folding_barriers</span> <span class="k">as</span> <span class="n">fold_bar</span>
<span class="kn">from</span> <span class="nn">.symbols</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.callback</span> <span class="kn">import</span> <span class="n">Callback</span>
<span class="kn">from</span> <span class="nn">.sequence</span> <span class="kn">import</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">.strand</span> <span class="kn">import</span> <span class="n">Strand</span><span class="p">,</span> <span class="n">StrandsBlock</span>
<span class="kn">from</span> <span class="nn">.basepair</span> <span class="kn">import</span> <span class="n">BasePair</span>
<span class="kn">from</span> <span class="nn">.position</span> <span class="kn">import</span> <span class="n">Position</span><span class="p">,</span> <span class="n">Direction</span>


<div class="viewcode-block" id="Motif">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif">[docs]</a>
<span class="k">class</span> <span class="nc">Motif</span><span class="p">(</span><span class="n">Callback</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a structural motif in an RNA Origami design.</span>

<span class="sd">    A `Motif` is composed of multiple `Strand` objects, defining an RNA secondary </span>
<span class="sd">    structure with base pair interactions. It supports coordinate locking, </span>
<span class="sd">    strand joining, sequence assignment, and 2D motif visualization.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    *strands : list of Strand, optional</span>
<span class="sd">        A list of `Strand` objects to initialize the motif.</span>
<span class="sd">    basepair : BasePair, dict, optional</span>
<span class="sd">        A dictionary defining base pair connections, with `Position` objects as keys </span>
<span class="sd">        and values representing paired positions.</span>
<span class="sd">    structure : str, optional</span>
<span class="sd">        A dot-bracket notation representation of the motif&#39;s structure.</span>
<span class="sd">        If this is provided, the `basepair` parameter is ignored.</span>
<span class="sd">    autopairing : bool, default True</span>
<span class="sd">        If True, automatically pairs bases based on complementary interactions.</span>
<span class="sd">        If a basepair or structure is given, autopairing is turned off.</span>
<span class="sd">    lock_coords : bool, default True</span>
<span class="sd">        If True, locks the coordinate system for all strands in the motif.</span>
<span class="sd">        When a strand coordinate transformed, all other strands are transformed.</span>
<span class="sd">    join : bool, default True</span>
<span class="sd">        If True, attempts to merge consecutive strands where possible.</span>
<span class="sd">    copy : bool, default False</span>
<span class="sd">        If True, creates copies of the input strands instead of using references.</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        Additional arguments to pass to the parent `Callback` class.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    autopairing : bool</span>
<span class="sd">        Indicates whether the motif automatically pairs bases.</span>
<span class="sd">    basepair : BasePair</span>
<span class="sd">        The base-pairing map of the motif.</span>
<span class="sd">        A double dictionary with `Position` objects as keys and values </span>
<span class="sd">        representing paired positions in the 2D representation.</span>
<span class="sd">    junctions : dict</span>
<span class="sd">        A dictionary with 2D Direction as key and Positions of the junctions as values.</span>
<span class="sd">    lock_coords : bool</span>
<span class="sd">        Indicates whether the strands coordinates are part of the same coordinate </span>
<span class="sd">        system.</span>
<span class="sd">    max_pos : tuple of int</span>
<span class="sd">        The maximum x, y coordinates occupied by the motif.</span>
<span class="sd">    min_pos : tuple of int</span>
<span class="sd">        The minimum x, y coordinates occupied by the motif. </span>
<span class="sd">    num_char : int</span>
<span class="sd">        The maximum length of the motif lines.</span>
<span class="sd">    num_lines : int</span>
<span class="sd">        The number of lines in the motif structure.</span>
<span class="sd">    pair_map : dict</span>
<span class="sd">        A mapping of paired bases indices (alternative to dot-bracket notation).</span>
<span class="sd">    positions : tuple of Position</span>
<span class="sd">        A tuple of the positions of each character of each strand in 2D space.</span>
<span class="sd">    seq_positions : tuple of Position</span>
<span class="sd">        The positions of each nucleotide in the motif sequence (x,y coordinates).</span>
<span class="sd">        Note: the sequence is always 5&#39; to 3&#39; in the motif.</span>
<span class="sd">    sequence : Sequence</span>
<span class="sd">        The nucleotide sequence of the motif. It&#39;s the concatenation of the sequence.</span>
<span class="sd">        of each strand, with 5&#39; to 3&#39; directionality.</span>
<span class="sd">    strands : list of Strand</span>
<span class="sd">        A list of strands composing the motif.</span>
<span class="sd">    structure : str</span>
<span class="sd">        The motif structure represented in dot-bracket notation.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The motif is built from strands and supports strand merging.</span>
<span class="sd">    - Base pairs can be set manually or inferred automatically.</span>
<span class="sd">    - Supports transformations, file export, and visual representation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                 <span class="o">*</span><span class="n">strands</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Strand</span><span class="p">],</span> 
                 <span class="n">basepair</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">structure</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                 <span class="n">autopairing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                 <span class="n">lock_coords</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                 <span class="n">join</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                 <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a Motif instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *strands : list of Strand</span>
<span class="sd">            List of strands to add to the motif.</span>
<span class="sd">        basepair : dict, optional</span>
<span class="sd">            The base-pairing map of the motif.</span>
<span class="sd">            A double dictionary with `Position` objects as keys and values </span>
<span class="sd">            representing paired positions in the 2D representation.</span>
<span class="sd">        structure : str, optional</span>
<span class="sd">            The structure of the motif in dot-bracket notation.</span>
<span class="sd">            If provided, the `basepair` parameter is ignored.</span>
<span class="sd">        autopairing : bool, default True</span>
<span class="sd">            Whether to enable automatic base pairing.</span>
<span class="sd">            If a basepair or structure is given, autopairing is turned off.</span>
<span class="sd">        lock_coords : bool, default True</span>
<span class="sd">            Whether to lock coordinates in the same coordinate system.</span>
<span class="sd">        join : bool, default True</span>
<span class="sd">            Whether to join consecutive strands.</span>
<span class="sd">        copy : bool, default False</span>
<span class="sd">            Whether to copy strands.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1">### Initialize the attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_seq_positions</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_pos</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_min_pos</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_junctions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sequence</span> <span class="o">=</span> <span class="n">Sequence</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pair_map</span> <span class="o">=</span> <span class="n">BasePair</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strands</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lock_coords</span> <span class="o">=</span> <span class="n">lock_coords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strands_block</span> <span class="o">=</span> <span class="n">StrandsBlock</span><span class="p">()</span> 
        
        <span class="c1">### STRANDS INITIALIZATION</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">strands</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> 
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">)</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Strand</span><span class="p">)):</span>
            <span class="c1"># if a single list of strands is passed, unpack it</span>
            <span class="n">strands</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">strands</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">extra</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;strands&#39;</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">())</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extra</span><span class="p">,</span> <span class="n">Strand</span><span class="p">):</span>
            <span class="n">strands</span> <span class="o">+=</span> <span class="p">(</span><span class="n">extra</span><span class="p">,</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extra</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">strands</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">extra</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`strands` keyword argument must be a Strand or an &quot;</span>
                            <span class="s2">&quot;iterable of Strands.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Strand</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strands</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All the elements in the strands input must be of type&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot; Strand. Got types </span><span class="si">{</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">strands</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="c1">### COPY/REGISTER STRANDS</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">strands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_strands_preserve_blocks</span><span class="p">(</span><span class="n">strands</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strands</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">register_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_updated_strands</span><span class="p">)</span>

        <span class="c1">### JOIN STRANDS</span>
        <span class="k">if</span> <span class="n">join</span><span class="p">:</span>
            <span class="n">strands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">join_strands</span><span class="p">(</span><span class="n">strands</span> <span class="o">=</span> <span class="n">strands</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strands</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">strands</span><span class="p">)</span> <span class="c1"># set the strands</span>

        <span class="c1">### LOCK COORDINATES</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock_coords</span><span class="p">:</span>
            <span class="c1"># IMPORTANT: look at the _coords to avoid locking strands </span>
            <span class="c1">#            that don&#39;t have coordinates </span>
            <span class="c1"># (therefore should not be locked)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_strands_block</span> <span class="o">=</span> <span class="n">StrandsBlock</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strands</span> <span class="p">])</span>
                                                <span class="c1">#  if not s._coords.is_empty()])</span>

        <span class="c1">### BASEPAIR/DOT-BRACKET INITIALIZATION</span>
        <span class="c1"># prioritize the structure</span>
        <span class="k">if</span> <span class="n">structure</span><span class="p">:</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">structure</span> <span class="o">=</span> <span class="n">structure</span>
            <span class="n">autopairing</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if basepair is given, set off autopairing</span>
            <span class="k">if</span> <span class="n">basepair</span><span class="p">:</span> 
                <span class="n">autopairing</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">autopairing</span> <span class="o">=</span> <span class="n">autopairing</span>
                <span class="n">basepair</span> <span class="o">=</span> <span class="n">BasePair</span><span class="p">()</span>
            <span class="c1"># initialize basepair property</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basepair</span> <span class="o">=</span> <span class="n">BasePair</span><span class="p">(</span><span class="n">basepair</span><span class="p">,</span> <span class="n">callback</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_updated_basepair</span><span class="p">)</span>

        <span class="c1"># set autopairing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_autopairing</span> <span class="o">=</span> <span class="n">autopairing</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the blueprint of the motif.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span>
        <span class="c1"># create the canvas</span>
        <span class="n">canvas_repr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_char</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_lines</span> 

        <span class="c1"># draw each strand to the canvas</span>
        <span class="k">for</span> <span class="n">strand</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">strand</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">canvas_repr</span><span class="p">,</span> <span class="n">return_string</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># add base pairing at position (if the base pairing position is free)</span>
        <span class="k">for</span> <span class="n">pos1</span><span class="p">,</span> <span class="n">pos2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">basepair</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># select the horizontal basepair symbol</span>
            <span class="k">if</span> <span class="n">pos1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pos1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> 
                <span class="n">pos</span> <span class="o">=</span> <span class="p">((</span><span class="n">pos1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">pos2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">pos1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">sym</span> <span class="o">=</span> <span class="s1">&#39;=&#39;</span>
            <span class="c1"># select the vertical basepair symbol</span>
            <span class="k">elif</span>  <span class="n">pos1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pos1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> 
                <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">pos1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">pos2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">sym</span> <span class="o">=</span> <span class="s1">&#39;â”Š&#39;</span>
            <span class="c1"># skip the basepair if it is not horizontal or vertical</span>
            <span class="k">else</span><span class="p">:</span> 
                <span class="k">continue</span>

            <span class="c1"># if the position is free, add the basepair symbol</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">canvas_repr</span><span class="p">)</span> <span class="ow">and</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">canvas_repr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> 
                    <span class="ow">and</span> <span class="n">canvas_repr</span><span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="s1">&#39; &#39;</span><span class="p">):</span> 
                <span class="n">canvas_repr</span><span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">canvas_repr</span><span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]][:</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> 
                                      <span class="o">+</span> <span class="n">sym</span> 
                                      <span class="o">+</span> <span class="n">canvas_repr</span><span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> 
                                      <span class="p">)</span>
            
            <span class="c1"># send a warning if the position is already occupied</span>
            <span class="k">else</span><span class="p">:</span> 
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Hidden basepair at position </span><span class="si">{</span><span class="n">pos</span><span class="si">}</span><span class="s2">.&quot;</span>
                              <span class="sa">f</span><span class="s2">&quot; Trying to pair </span><span class="si">{</span><span class="n">pos1</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="n">pos2</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">canvas_repr</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the list of strands.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Strand&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the strand at index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strands</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">strand</span><span class="p">:</span> <span class="s1">&#39;Strand&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the strand at index and try to join.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strand</span><span class="p">,</span> <span class="n">Strand</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">strand</span><span class="si">}</span><span class="s2"> is not a Strand object.&quot;</span><span class="p">)</span>
        <span class="c1"># register the callback to update the motif</span>
        <span class="n">strand</span><span class="o">.</span><span class="n">register_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_updated_strands</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strands</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">strand</span>
        <span class="c1"># indicate that the strands have been updated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">join_strands</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_strands</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock_coords</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_strands_block</span> <span class="o">=</span> <span class="n">StrandsBlock</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strands</span> <span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updated_strands</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the number of strands.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_strands</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;Motif&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Motif&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add two motifs together by stacking them horizontally.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Motif</span>
<span class="sd">            The motif to be added.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Motif</span>
<span class="sd">            The new motif resulting from the addition.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `other` is not a `Motif` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_addition</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="c1"># edge cases</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Motif</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># create a copy of the motif to add. </span>
        <span class="c1"># All operations will be performed on the copies</span>
        <span class="n">self_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> 
        <span class="n">other_copy</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># align the motifs horizontally</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">self_copy</span><span class="p">,</span> <span class="n">other_copy</span><span class="p">)</span>  
        <span class="c1"># get the x shifts to move the motifs</span>
        <span class="n">x_shifts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sequential_shift</span><span class="p">([</span><span class="n">self_copy</span><span class="p">,</span> <span class="n">other_copy</span><span class="p">],</span> 
                                             <span class="n">position_based</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># move motif to the right of the first motif</span>
        <span class="n">other_copy</span><span class="o">.</span><span class="n">shift</span><span class="p">((</span><span class="n">x_shifts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span> 

        <span class="c1"># if one of the two motifs doesn&#39;t use autopairing, </span>
        <span class="c1"># set it false and update the basepair dictionary</span>
        <span class="k">if</span> <span class="n">self_copy</span><span class="o">.</span><span class="n">autopairing</span> <span class="ow">and</span> <span class="n">other_copy</span><span class="o">.</span><span class="n">autopairing</span><span class="p">:</span>
            <span class="n">new_basepair</span> <span class="o">=</span> <span class="n">BasePair</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_basepair</span> <span class="o">=</span> <span class="n">self_copy</span><span class="o">.</span><span class="n">basepair</span>
            <span class="n">new_basepair</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">other_copy</span><span class="o">.</span><span class="n">basepair</span><span class="p">)</span>

        <span class="c1"># return the new motif collecting the strands</span>
        <span class="k">return</span> <span class="n">Motif</span><span class="p">(</span><span class="n">strands</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">self_copy</span><span class="p">)</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">other_copy</span><span class="p">),</span> 
                     <span class="n">basepair</span><span class="o">=</span><span class="n">new_basepair</span><span class="p">)</span> 

    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;Motif&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Motif&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add another motif to the current motif in place and join the strands.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Motif</span>
<span class="sd">            The motif to be added.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Motif</span>
<span class="sd">            The updated motif.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_addition</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="c1"># edge cases</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        
        <span class="c1"># copy the other motif to prevent modifying it </span>
        <span class="n">other_copy</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1"># align the motifs horizontally</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_copy</span><span class="p">)</span>  
            <span class="n">x_shifts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sequential_shift</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_copy</span><span class="p">],</span> 
                                                 <span class="n">position_based</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># move motif to the right of the first motif</span>
            <span class="n">other_copy</span><span class="o">.</span><span class="n">shift</span><span class="p">((</span><span class="n">x_shifts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span> 

        <span class="c1"># if other has autopairing off, set it off</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">other_copy</span><span class="o">.</span><span class="n">autopairing</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_autopairing</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_basepair</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">other_copy</span><span class="o">.</span><span class="n">basepair</span><span class="p">)</span>

        <span class="c1"># add the other strands to self</span>
        <span class="k">for</span> <span class="n">strand</span> <span class="ow">in</span> <span class="n">other_copy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_strands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">strand</span><span class="p">)</span>

        <span class="c1"># join the strands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">join_strands</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_strands</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock_coords</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_strands_block</span> <span class="o">=</span> <span class="n">StrandsBlock</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strands</span> <span class="p">])</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">register_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_updated_strands</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_updated_strands</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s1">&#39;Motif&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Motif&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enable right addition for motifs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; True if the motif contains at least one valid strand, False otherwise. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strands</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strands</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>
    
    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                     <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s1">&#39;Strand&#39;</span><span class="p">,</span> <span class="s1">&#39;Sequence&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;BasePair&#39;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Check if the motif contains a strand, sequence, or base pair. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="n">Strand</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strands</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="n">Sequence</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">other</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strands</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="n">BasePair</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">basepair</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; True if two motifs have equal strands and equal basepair. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Motif</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="k">for</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s1</span> <span class="o">!=</span> <span class="n">s2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">basepair</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">basepair</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="k">return</span> <span class="kc">True</span>
    
    <span class="c1">### </span>
    <span class="c1">### PROPERTIES</span>
    <span class="c1">###</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">autopairing</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicates whether the motif automatically pairs bases.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autopairing</span>
    
    <span class="nd">@autopairing</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">autopairing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">autopairing</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the autopairing property.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_autopairing</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">autopairing</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">autopairing</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_basepair</span> <span class="o">=</span> <span class="n">BasePair</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_basepair</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">basepair</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BasePair</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A dictionary with positions as key and the paired position as values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autopairing</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span>
                                 <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sequence</span> 
                                 <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basepair</span><span class="p">):</span>
            <span class="c1"># calculate the basepair dictionary</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_basepair</span><span class="p">()</span> 
            <span class="c1"># reset the dot bracket</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span> <span class="o">=</span> <span class="kc">None</span>  

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basepair</span> 

    <span class="nd">@basepair</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">basepair</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                 <span class="n">basepair_dict</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Position</span><span class="p">,</span> <span class="n">Position</span><span class="p">],</span> <span class="n">BasePair</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the basepair dictionary and turn autopairing off.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">basepair_dict</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">BasePair</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">basepair_dict</span><span class="si">}</span><span class="s2"> must be a dictionary or a BasePair&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot; object. Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">basepair_dict</span><span class="p">)</span><span class="si">}</span><span class="s2"> instead.&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">basepair_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">Position</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="n">Position</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> 
                             <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">basepair_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error converting the basepair dictionary to&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot; a dictionary of Position objects: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_autopairing</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_basepair</span> <span class="o">=</span> <span class="n">BasePair</span><span class="p">(</span><span class="n">basepair_dict</span><span class="p">,</span> <span class="n">callback</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_updated_basepair</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trigger_callbacks</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">junctions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A dictionary with Direction as key (right: (1,0), bottom: (0,1), </span>
<span class="sd">        left: (-1,0), top: (0,1)) and an ordered list of junction positon as value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">### if the junctions are already calculated return them</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_positions</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_junctions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lock_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Boolean indicating if the coordinates are locked in the same block.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lock_coords</span>

    <span class="nd">@lock_coords</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">lock_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lock_coords</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set wether the strands coordinates must be locked in the same block.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lock_coords</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">lock_coords</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The maximum x, y coordinates occupied of the motif.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_positions</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_pos</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">min_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The minimum x, y coordinates occupied of the motif.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_positions</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_pos</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_char</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The maximum length of the motif lines.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_positions</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of lines in the motif structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_positions</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pair_map</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The dictionary of the paired indexes (alternative to the dot bracket </span>
<span class="sd">        notation). </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pair_map</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pair_map</span>

        <span class="n">pos_to_ind</span> <span class="o">=</span> <span class="p">{</span><span class="n">pos</span><span class="p">:</span> <span class="n">ind</span> <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_positions</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pair_map</span> <span class="o">=</span> <span class="n">BasePair</span><span class="p">({</span><span class="n">ind</span><span class="p">:</span> <span class="n">pos_to_ind</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basepair</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span>
                                            <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">pos_to_ind</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>     
         
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pair_map</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">positions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Position</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        A tuple of the positions of each character of each strand in 2D space</span>
<span class="sd">        (x,y coordinates).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_positions</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the sequence of the motif.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sequence</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sequence</span> 
        
        <span class="c1">### calculate the sequence</span>
        <span class="n">tot_seq</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="o">.</span><span class="n">sequence</span><span class="p">:</span> <span class="c1"># skip the strands without sequence</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">directionality</span> <span class="o">==</span> <span class="s1">&#39;35&#39;</span><span class="p">:</span>
                <span class="n">tot_seq</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">sequence</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tot_seq</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">sequence</span><span class="p">)</span>
            <span class="n">tot_seq</span> <span class="o">+=</span> <span class="s1">&#39;&amp;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_sequence</span> <span class="o">=</span> <span class="n">Sequence</span><span class="p">(</span><span class="n">tot_seq</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">))</span> <span class="c1"># remove separator at the end</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sequence</span>

    <span class="nd">@sequence</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq_list</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the sequence of each strand the motif </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        seq_list : str or Sequence or list of str or Sequence</span>
<span class="sd">            The list of sequences to set to the strands. </span>
<span class="sd">            If a single string is passed, it is split by &#39;&amp;&#39;.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the number of sequences is different from the number of strands.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seq_list</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">))</span> 
                <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seq_list</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> 
                <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">))</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">seq_list</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">seq_list</span><span class="si">}</span><span class="s2"> must be a string, a Sequence object or &quot;</span>
                             <span class="s2">&quot;a list of strings or Sequence objects. &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">seq_list</span><span class="p">)</span><span class="si">}</span><span class="s2"> instead.&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seq_list</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)):</span>
            <span class="n">seq_list</span> <span class="o">=</span> <span class="n">seq_list</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq_list</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of sequences must be equal to the number of&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot; strands. Got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">seq_list</span><span class="p">)</span><span class="si">}</span><span class="s2"> sequences &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot; for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> strands.&quot;</span><span class="p">)</span>
        
        <span class="n">seq_list</span> <span class="o">=</span> <span class="n">seq_list</span><span class="p">[:]</span> <span class="c1"># copy the list</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="n">seq_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">direct</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">directionality</span> <span class="o">==</span> <span class="s1">&#39;53&#39;</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">s</span><span class="o">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[::</span><span class="n">direct</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">seq_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Position</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        The positions of each nucleotide in the motif sequence (x,y coordinates).</span>
<span class="sd">        The sequence has always the directionality 5&#39; to 3&#39; </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_positions</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seq_positions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">strands</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="s1">&#39;Strand&#39;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The list of strands in the motif.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strands</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">structure</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the dot bracket representation of the motif.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">### if the dot bracket is already calculated return it</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span>

        <span class="c1"># calculate the break points of the strands</span>
        <span class="n">break_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sym</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">)</span> <span class="k">if</span> <span class="n">sym</span> <span class="o">==</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">]</span>

        <span class="c1">### CREATE THE DOT BRACKET NOTATION ###</span>
        <span class="n">dotbracket</span> <span class="o">=</span> <span class="n">pair_map_to_dot_bracket</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pair_map</span><span class="p">,</span> 
                                             <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)))</span> 

        <span class="c1">### ADD THE BREAK POINTS ###</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">break_points</span><span class="p">):</span>
            <span class="n">dotbracket</span> <span class="o">=</span> <span class="n">dotbracket</span><span class="p">[:</span><span class="n">bp</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;&amp;&#39;</span> <span class="o">+</span> <span class="n">dotbracket</span><span class="p">[</span><span class="n">bp</span><span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span> <span class="o">=</span> <span class="n">dotbracket</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span>

    <span class="nd">@structure</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the dot bracket notation of the motif, it updates the basepair.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">structure</span><span class="si">}</span><span class="s2"> must be a string. &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span><span class="si">}</span><span class="s2"> instead.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The length of the dot bracket must be equal to the&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot; length of the sequence.&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">basepair_dict</span> <span class="o">=</span> <span class="n">BasePair</span><span class="p">()</span>
        <span class="c1"># get the dictionary of paired indexes without the separation symbol</span>
        <span class="n">pair_map</span> <span class="o">=</span> <span class="n">dot_bracket_to_pair_map</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span> 
        <span class="c1"># get the list of base positions in simple order</span>

         <span class="c1"># iterate over the base positions</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_positions</span><span class="p">):</span>
            <span class="n">paired</span> <span class="o">=</span> <span class="n">pair_map</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="c1"># the index of the base position is paired to something</span>
            <span class="k">if</span> <span class="n">paired</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
                <span class="n">basepair_dict</span><span class="p">[</span><span class="n">Position</span><span class="p">(</span><span class="n">pos</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Position</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_positions</span><span class="p">[</span><span class="n">paired</span><span class="p">])</span>

        <span class="c1"># set the basepair dictionary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basepair</span> <span class="o">=</span> <span class="n">basepair_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pair_map</span> <span class="o">=</span> <span class="n">pair_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span> <span class="o">=</span> <span class="n">structure</span>

    <span class="c1">### </span>
    <span class="c1">### CLASS METHODS</span>
    <span class="c1">###</span>

<div class="viewcode-block" id="Motif.concat">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif.concat">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> 
               <span class="o">*</span><span class="n">motifs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;Motif&quot;</span><span class="p">],</span> 
               <span class="n">axis</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> 
               <span class="n">extend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
               <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
               <span class="n">align</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
               <span class="n">position_based</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
               <span class="n">align_junctions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
               <span class="n">unlock_strands</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
               <span class="n">return_shifts</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Motif&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenate multiple motifs along a specified axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *motifs : list of Motif</span>
<span class="sd">            List of motifs to concatenate.</span>
<span class="sd">        axis : int, default 1</span>
<span class="sd">            The numpy axis along which motifs are aligned.</span>
<span class="sd">            1 for horizontal alignment, 0 for vertical alignment.</span>
<span class="sd">        extend : bool, default False</span>
<span class="sd">            Whether to extend junctions before concatenation.</span>
<span class="sd">        copy : bool, default True</span>
<span class="sd">            Whether to copy motifs before concatenation.</span>
<span class="sd">        align : bool, default True</span>
<span class="sd">            Whether to align motifs before concatenation.</span>
<span class="sd">        position_based : bool, default False</span>
<span class="sd">            Whether to align motifs based on positions instead of junctions.</span>
<span class="sd">        align_junctions : list of tuple, optional</span>
<span class="sd">            List of junction indices for alignment.</span>
<span class="sd">        unlock_strands : bool, default False</span>
<span class="sd">            Whether to unlock all strands, so they are not part </span>
<span class="sd">            of the same Strand block (different coordinate systems).</span>
<span class="sd">        return_shifts : bool, default False</span>
<span class="sd">            Whether to return the shift values for each motif to be aligned</span>
<span class="sd">            and concatenated. If True, a list of tuples with the shifts is returned,</span>
<span class="sd">            along with the concatenated motif (useful for Origami alignment).</span>

<span class="sd">        **kwargs : dict</span>
<span class="sd">            Additional arguments to pass to the Motif constructor. </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Motif</span>
<span class="sd">            The concatenated Motif object.</span>
<span class="sd">        List[Tuple[int, int]], optional</span>
<span class="sd">            The list of shifts applied to each motif during alignment.</span>
<span class="sd">            Only returned if return_shifts is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">motifs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> 
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">motifs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">)</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">motifs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Motif</span><span class="p">)):</span>
            <span class="c1"># if a single list of motifs is passed, unpack it</span>
            <span class="n">motifs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">motifs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">extra</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;motifs&#39;</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">()))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extra</span><span class="p">,</span> <span class="n">Motif</span><span class="p">):</span>
            <span class="n">motifs</span> <span class="o">+=</span> <span class="p">(</span><span class="n">extra</span><span class="p">,)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extra</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">motifs</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">extra</span><span class="p">)</span>
        
        <span class="c1"># check if all the elements in the motifs input are of type Motif</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Motif</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">motifs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All the elements in the motifs input must be of type&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot; Motif. Got types </span><span class="si">{</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">motifs</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="c1"># make a motif list and remove the empty motifs</span>
        <span class="n">motifs</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">motifs</span> <span class="k">if</span> <span class="n">m</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">motifs</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">motifs</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">return_shifts</span><span class="p">:</span>
            <span class="c1"># create a list of shifts for each motif</span>
            <span class="n">shifts</span> <span class="o">=</span> <span class="p">[</span><span class="n">Position</span><span class="o">.</span><span class="n">zero</span><span class="p">()]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">motifs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">align</span><span class="p">:</span>
            <span class="n">aligned</span> <span class="o">=</span> <span class="n">Motif</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="o">*</span><span class="n">motifs</span><span class="p">,</span> 
                                  <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> 
                                  <span class="n">align_junctions</span><span class="o">=</span><span class="n">align_junctions</span><span class="p">,</span>
                                  <span class="n">return_shifts</span><span class="o">=</span><span class="n">return_shifts</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">return_shifts</span><span class="p">:</span>
                <span class="n">aligned</span><span class="p">,</span> <span class="n">shifts</span> <span class="o">=</span> <span class="n">aligned</span>

        <span class="k">else</span> <span class="p">:</span>
            <span class="n">aligned</span> <span class="o">=</span> <span class="n">motifs</span>

        <span class="c1"># trick to handle all the axis at once</span>
        <span class="n">x_pos</span> <span class="o">=</span> <span class="n">axis</span>
        <span class="n">y_pos</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="ow">not</span> <span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">extend</span><span class="p">:</span>
            <span class="c1"># Extend the junctions</span>
            <span class="n">max_extend</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">m</span><span class="o">.</span><span class="n">max_pos</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">aligned</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">extend_until</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">extend_until</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_extend</span>
            <span class="n">aligned</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">extend_junctions</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="n">extend_until</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">aligned</span><span class="p">]</span> 

        <span class="c1"># prepare the motif shifting them two by two</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">m1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">aligned</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">m2</span> <span class="o">=</span> <span class="n">aligned</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># calculate the shift based on the positions</span>
            <span class="k">if</span> <span class="n">position_based</span><span class="p">:</span> 
                <span class="n">max_pos_m1</span> <span class="o">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">max_pos</span><span class="p">[</span><span class="n">y_pos</span><span class="p">]</span>
                <span class="n">min_pos_m2</span> <span class="o">=</span> <span class="n">m2</span><span class="o">.</span><span class="n">min_pos</span><span class="p">[</span><span class="n">y_pos</span><span class="p">]</span>
            
            <span class="c1"># calculate the shift based on the junctions</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">m1_junct</span> <span class="o">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">junctions</span><span class="p">[</span><span class="n">Position</span><span class="p">((</span><span class="n">x_pos</span><span class="p">,</span><span class="n">y_pos</span><span class="p">))]</span>
                <span class="n">m2_junct</span> <span class="o">=</span> <span class="n">m2</span><span class="o">.</span><span class="n">junctions</span><span class="p">[</span><span class="n">Position</span><span class="p">((</span><span class="o">-</span><span class="n">x_pos</span><span class="p">,</span><span class="o">-</span><span class="n">y_pos</span><span class="p">))]</span>

                <span class="k">if</span> <span class="n">m1_junct</span> <span class="ow">and</span> <span class="n">m2_junct</span><span class="p">:</span>
                    <span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="n">align_junctions</span> <span class="ow">and</span> <span class="n">align_junctions</span><span class="p">[</span><span class="n">ind</span><span class="p">]:</span>
                        <span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span> <span class="o">=</span> <span class="n">align_junctions</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
                    <span class="n">max_pos_m1</span> <span class="o">=</span> <span class="n">m1_junct</span><span class="p">[</span><span class="n">ind1</span><span class="p">][</span><span class="n">y_pos</span><span class="p">]</span>
                    <span class="n">min_pos_m2</span> <span class="o">=</span> <span class="n">m2_junct</span><span class="p">[</span><span class="n">ind2</span><span class="p">][</span><span class="n">y_pos</span><span class="p">]</span>

                <span class="c1"># No junctions, just place the motifs one after the other</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">max_pos_m1</span> <span class="o">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">max_pos</span><span class="p">[</span><span class="n">y_pos</span><span class="p">]</span>
                    <span class="n">min_pos_m2</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="n">m2</span><span class="o">.</span><span class="n">min_pos</span><span class="p">[</span><span class="n">y_pos</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_pos_m1</span><span class="p">:</span> 
                        <span class="c1"># if the second motif is already shifted, don&#39;t shift</span>
                        <span class="n">max_pos_m1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="c1"># Calculate the shift for the axis</span>
            <span class="n">shift_pos</span> <span class="o">=</span> <span class="n">Position</span><span class="p">((</span><span class="n">x_pos</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_pos_m1</span> <span class="o">-</span> <span class="n">min_pos_m2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                                  <span class="n">y_pos</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_pos_m1</span> <span class="o">-</span> <span class="n">min_pos_m2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>

            <span class="c1"># Apply the shift</span>
            <span class="n">m2</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">shift_pos</span><span class="p">)</span>
            
            <span class="c1"># update the shifts</span>
            <span class="k">if</span> <span class="n">return_shifts</span><span class="p">:</span>
                <span class="n">shifts</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">shifts</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift_pos</span>

        <span class="c1">### BASEPAIRS HANDLING</span>
        <span class="n">basepair</span> <span class="o">=</span> <span class="n">BasePair</span><span class="p">()</span>
        <span class="c1"># if all the motifs have autopairing on, the new motif has autopairing on</span>
        <span class="n">autopairing</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="n">m</span><span class="o">.</span><span class="n">autopairing</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">aligned</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">autopairing</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">aligned</span><span class="p">:</span>
                    <span class="n">basepair</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">basepair</span><span class="p">)</span>

        <span class="c1">### STRANDS LOCKING</span>
        <span class="k">if</span> <span class="n">unlock_strands</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">aligned</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span>
                    <span class="n">s</span><span class="o">.</span><span class="n">strands_block</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1"># create a object of the class</span>
        <span class="n">new_motif</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">new_motif</span><span class="o">.</span><span class="n">_autopairing</span> <span class="o">=</span> <span class="n">autopairing</span>
        <span class="n">new_motif</span><span class="o">.</span><span class="n">_basepair</span> <span class="o">=</span> <span class="n">basepair</span>
        <span class="n">new_motif</span><span class="o">.</span><span class="n">replace_all_strands</span><span class="p">([</span><span class="n">strand</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">aligned</span> <span class="k">for</span> <span class="n">strand</span> <span class="ow">in</span> <span class="n">m</span><span class="p">],</span> 
                                      <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                                      <span class="n">join</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># used in Origami assembly</span>
        <span class="k">if</span> <span class="n">return_shifts</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new_motif</span><span class="p">,</span> <span class="n">shifts</span>
        
        <span class="k">return</span> <span class="n">new_motif</span></div>


<div class="viewcode-block" id="Motif.from_file">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif.from_file">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Motif&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a Motif object from a text file containing a motif sketch.</span>
<span class="sd">        Each Strand is read starting from the `5` symbol. If you want to add the 5&#39; </span>
<span class="sd">        terminal symbol, start the strand with `55`. Only one symbol should be placed</span>
<span class="sd">        next to the `5` start of the strand in order to guess the right direction.</span>
<span class="sd">        Alternatively, you can use symbols `^v&gt;&lt;` to start a strand and indicate </span>
<span class="sd">        the start direction (up, down, right, left); in this case you can place</span>
<span class="sd">        multiple symbols next to the start symbol.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file_path : str</span>
<span class="sd">            Path to the file containing the motif structure.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Additional arguments to pass to the Motif constructor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Motif</span>
<span class="sd">            The constructed Motif object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">motif_text</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_text</span><span class="p">(</span><span class="n">motif_text</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Motif.from_list">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif.from_list">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_list</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">motif_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Motif&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a Motif object from a list of strings representing a motif sketch.</span>
<span class="sd">        Each Strand is read starting from the `5` symbol. If you want to add the 5&#39; </span>
<span class="sd">        terminal symbol, start the strand with `55`. Only one symbol should be placed</span>
<span class="sd">        next to the `5` start of the strand in order to guess the right direction.</span>
<span class="sd">        Alternatively, you can use symbols `^v&gt;&lt;` to start a strand and indicate </span>
<span class="sd">        the start direction (up, down, right, left); in this case you can place</span>
<span class="sd">        multiple symbols next to the start symbol.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        motif_list : list of str</span>
<span class="sd">            The list of strings representing the motif.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Additional arguments to pass to the Motif constructor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Motif</span>
<span class="sd">            The constructed Motif object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">### initialize the variables</span>
        <span class="n">strand_list</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># list of strands</span>
        <span class="n">mapped_pos</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="c1"># set of visited positions</span>
        
        <span class="c1">### Get the maximum x and y positions</span>
        <span class="n">max_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">motif_list</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> 
        <span class="n">max_y</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">motif_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1">### Uniform the line length</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">motif_list</span><span class="p">):</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">max_x</span> <span class="o">-</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">diff</span><span class="p">:</span>
                <span class="n">motif_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">line</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="n">diff</span>

        <span class="c1">### TRACE THE STRANDS STARTING WITH ^v&gt;&lt;</span>
        <span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">motif_list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">char</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                <span class="c1"># check a start of a strand</span>
                <span class="k">if</span> <span class="n">char</span> <span class="ow">in</span> <span class="s2">&quot;^v&gt;&lt;&quot;</span><span class="p">:</span> <span class="c1"># Special direction characters</span>
                    <span class="k">if</span> <span class="n">char</span> <span class="o">==</span> <span class="s1">&#39;^&#39;</span><span class="p">:</span>
                        <span class="n">direction</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">char</span> <span class="o">==</span> <span class="s1">&#39;v&#39;</span><span class="p">:</span>
                        <span class="n">direction</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">char</span> <span class="o">==</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">:</span>
                        <span class="n">direction</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">char</span> <span class="o">==</span> <span class="s1">&#39;&lt;&#39;</span><span class="p">:</span>
                        <span class="n">direction</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    
                    <span class="c1"># get the strand direction</span>
                    <span class="n">start_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">direction</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span> <span class="o">+</span> <span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="c1"># get the strand characters</span>
                    <span class="n">strand_chars</span> <span class="o">=</span> <span class="n">Motif</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">motif_list</span><span class="p">,</span> 
                                               <span class="n">start_pos</span><span class="p">,</span> 
                                               <span class="n">direction</span><span class="p">,</span> 
                                               <span class="n">limits</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span><span class="p">))</span>
                    <span class="c1"># create the Strand object</span>
                    <span class="n">strand</span> <span class="o">=</span> <span class="n">Strand</span><span class="p">(</span><span class="n">strand_chars</span><span class="p">,</span> 
                                    <span class="n">directionality</span><span class="o">=</span><span class="s1">&#39;53&#39;</span><span class="p">,</span> 
                                    <span class="n">start</span><span class="o">=</span><span class="n">start_pos</span><span class="p">,</span> 
                                    <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)</span>
                    <span class="c1"># add the Strand to the list</span>
                    <span class="n">strand_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">strand</span><span class="p">)</span>
                    <span class="c1"># update the visited positions</span>
                    <span class="n">mapped_pos</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">strand</span><span class="o">.</span><span class="n">positions</span><span class="p">))</span>

        <span class="c1">### TRACE THE STRANDS STARTING WITH 5</span>
        <span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">motif_list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">char</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                <span class="c1"># check a start of a strand</span>
                <span class="k">if</span> <span class="n">char</span> <span class="o">==</span> <span class="s2">&quot;5&quot;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mapped_pos</span><span class="p">:</span> 
                    <span class="n">right_sym</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">bot_sym</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">left_sym</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">top_sym</span> <span class="o">=</span> <span class="kc">None</span>

                    <span class="c1"># try to guess the direction based on the next symbol</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">max_x</span><span class="p">:</span>
                        <span class="n">right_sym</span> <span class="o">=</span> <span class="n">motif_list</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">max_y</span><span class="p">:</span>
                        <span class="n">bot_sym</span> <span class="o">=</span> <span class="n">motif_list</span><span class="p">[</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">left_sym</span> <span class="o">=</span> <span class="n">motif_list</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">top_sym</span> <span class="o">=</span> <span class="n">motif_list</span><span class="p">[</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>

                    <span class="n">direction</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="n">right_sym</span> <span class="ow">in</span> <span class="n">accept_symbol</span> <span class="ow">and</span> <span class="n">motif_list</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39; 3&#39;</span><span class="p">:</span>
                        <span class="n">direction</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">bot_sym</span> <span class="ow">in</span> <span class="n">accept_symbol</span> <span class="ow">and</span> <span class="n">bot_sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39; 3&#39;</span><span class="p">:</span>
                        <span class="n">direction</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">left_sym</span> <span class="ow">in</span> <span class="n">accept_symbol</span> <span class="ow">and</span> <span class="n">left_sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39; 3&#39;</span><span class="p">:</span>
                        <span class="n">direction</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">top_sym</span> <span class="ow">in</span> <span class="n">accept_symbol</span> <span class="ow">and</span> <span class="n">top_sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39; 3&#39;</span><span class="p">:</span>
                        <span class="n">direction</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">MotifStructureError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Strand at position </span><span class="si">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="si">}</span><span class="s2">&quot;</span>
                                                  <span class="s2">&quot; has no direction.&quot;</span><span class="p">)</span>
                    
                    <span class="c1"># get the strand direction</span>
                    <span class="n">start_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">direction</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span> <span class="o">+</span> <span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="c1"># get the strand characters</span>
                    <span class="n">strand_chars</span> <span class="o">=</span> <span class="n">Motif</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">motif_list</span><span class="p">,</span> 
                                               <span class="n">start_pos</span><span class="p">,</span> 
                                               <span class="n">direction</span><span class="p">,</span> 
                                               <span class="n">limits</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span><span class="p">))</span>
                    <span class="c1"># create the Strand object</span>
                    <span class="n">strand</span> <span class="o">=</span> <span class="n">Strand</span><span class="p">(</span><span class="n">strand_chars</span><span class="p">,</span> 
                                    <span class="n">directionality</span><span class="o">=</span><span class="s1">&#39;53&#39;</span><span class="p">,</span> 
                                    <span class="n">start</span><span class="o">=</span><span class="n">start_pos</span><span class="p">,</span> 
                                    <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)</span>
                    <span class="c1"># add the Strand to the list</span>
                    <span class="n">strand_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">strand</span><span class="p">)</span>
                    <span class="c1"># update the visited positions</span>
                    <span class="n">mapped_pos</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">strand</span><span class="o">.</span><span class="n">positions</span><span class="p">))</span>

        <span class="c1">### TRACE THE BASEPAIRS ###</span>
        <span class="n">basepair</span> <span class="o">=</span> <span class="n">BasePair</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">motif_list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">sym</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                <span class="n">pos1</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># if found a basepair symbol, add the position to the dictionary</span>
                <span class="k">if</span> <span class="n">sym</span> <span class="ow">in</span> <span class="s2">&quot;â”Š!*:&quot;</span><span class="p">:</span> <span class="c1"># vertical basepair</span>
                    <span class="n">pos1</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> 
                    <span class="n">pos2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">sym</span> <span class="ow">in</span> <span class="s2">&quot;=&quot;</span><span class="p">:</span> <span class="c1"># horizontal basepair</span>
                    <span class="n">pos1</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
                    <span class="n">pos2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">pos1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">basepair</span><span class="p">[</span><span class="n">Position</span><span class="p">(</span><span class="n">pos1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Position</span><span class="p">(</span><span class="n">pos2</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">strands</span><span class="o">=</span><span class="n">strand_list</span><span class="p">,</span> <span class="n">basepair</span><span class="o">=</span><span class="n">basepair</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Motif.from_structure">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif.from_structure">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_structure</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
                       <span class="n">structure</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">BasePair</span><span class="p">,</span> <span class="n">Node</span><span class="p">],</span> 
                       <span class="n">sequence</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">pk_energy</span><span class="o">=-</span><span class="mf">8.5</span><span class="p">,</span> 
                       <span class="n">pk_denergy</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Motif&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a structure representation to a Motif object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        structure : Union[str, dict, BasePair, Node]</span>
<span class="sd">            The structure representation to convert.</span>
<span class="sd">        sequence : str, optional</span>
<span class="sd">            The sequence or sequence constraints of the motif.</span>
<span class="sd">        pk_energy : float, optional</span>
<span class="sd">            The energy of the pseudoknots (if present).</span>
<span class="sd">        pk_denergy : float, optional</span>
<span class="sd">            The energy tolerance of the pseudoknots (if present).</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Additional arguments to pass to the Motif constructor.</span>
<span class="sd">        </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Motif</span>
<span class="sd">            The Motif object created from the structure representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># import here to avoid circular imports</span>
        <span class="kn">from</span> <span class="nn">.origami</span> <span class="kn">import</span> <span class="n">Origami</span>

        <span class="k">if</span> <span class="n">sequence</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sequence</span> <span class="o">=</span> <span class="s1">&#39;N&#39;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The sequence length must be equal to the structure &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;length. Got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># input dot-bracket notation</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">dot_bracket_to_tree</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> 
                                       <span class="n">sequence</span><span class="o">=</span><span class="n">sequence</span><span class="p">)</span>
            <span class="n">pair_map</span> <span class="o">=</span> <span class="n">dot_bracket_to_pair_map</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>
        <span class="c1"># input pair map</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="p">(</span><span class="n">BasePair</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
            <span class="n">pair_map</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">dot_bracket_to_tree</span><span class="p">(</span><span class="n">pair_map_to_dot_bracket</span><span class="p">(</span><span class="n">structure</span><span class="p">),</span> 
                                    <span class="n">sequence</span><span class="o">=</span><span class="n">sequence</span><span class="p">)</span>
            <span class="n">structure</span> <span class="o">=</span> <span class="n">pair_map_to_dot_bracket</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>
        <span class="c1"># input tree</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">structure</span>
            <span class="n">pair_map</span> <span class="o">=</span> <span class="n">dot_bracket_to_pair_map</span><span class="p">(</span><span class="n">tree_to_dot_bracket</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
            <span class="n">structure</span> <span class="o">=</span> <span class="n">tree_to_dot_bracket</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid structure representation: </span><span class="si">{</span><span class="n">structure</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># initialize the origami object</span>
        <span class="n">origami</span> <span class="o">=</span> <span class="n">Origami</span><span class="p">([[]],</span> <span class="n">align</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="n">ss_assembly</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">current_index</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">recursive_build_origami</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">insert_at</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flip</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Recursively build the origami from the tree representation.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">nonlocal</span> <span class="n">current_index</span>
            <span class="c1"># initialize the variables</span>
            <span class="k">if</span> <span class="n">insert_at</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">insert_at</span> <span class="o">=</span> <span class="n">current_index</span>
            <span class="n">motif</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1">### BASE CASES: sequence break, unpaired nucleotide, stem</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
                <span class="k">return</span>
            
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s1">&#39;(&#39;</span><span class="p">:</span>
                <span class="n">motif</span> <span class="o">=</span> <span class="n">Motif</span><span class="p">(</span><span class="n">Strand</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">seq</span><span class="p">),</span>
                            <span class="n">Strand</span><span class="p">(</span><span class="n">sequence</span><span class="p">[</span><span class="n">pair_map</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">index</span><span class="p">]],</span>
                                    <span class="n">start</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">directionality</span><span class="o">=</span><span class="s1">&#39;35&#39;</span><span class="p">),</span>
                            <span class="n">basepair</span><span class="o">=</span><span class="p">{(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)},</span>
                            <span class="p">)</span>
                
            <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span>
                <span class="n">motif</span> <span class="o">=</span> <span class="n">Motif</span><span class="p">(</span><span class="n">Strand</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">seq</span><span class="p">),</span>
                            <span class="n">Strand</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                            <span class="p">)</span>
                
            <span class="c1"># add the motif and update the current index</span>
            <span class="k">if</span> <span class="n">motif</span><span class="p">:</span>
                <span class="n">origami</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">insert_at</span><span class="p">,</span>
                            <span class="n">motif</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">flip</span><span class="p">,</span> <span class="n">flip</span><span class="p">)</span>
                            <span class="p">)</span>
                <span class="n">current_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># increment the x index</span>

            <span class="c1"># recursive call for the children</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">child_inds</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="c1"># check each child before recursive call</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
                    <span class="n">insert_at</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">flip</span> <span class="o">=</span> <span class="kc">False</span>

                    <span class="c1"># bulge after a stem</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span> 
                            <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">label</span><span class="o">==</span><span class="s1">&#39;(&#39;</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[:</span> <span class="n">i</span><span class="p">])):</span>
                        <span class="n">insert_at</span> <span class="o">=</span> <span class="n">child_inds</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                        <span class="n">flip</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="c1"># sequence break + only unpaired</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">label</span> <span class="ow">in</span> <span class="s1">&#39;.&amp;&#39;</span> <span class="ow">and</span> 
                            <span class="nb">all</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">label</span> <span class="ow">in</span> <span class="s1">&#39;.&amp;&#39;</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="s1">&#39;&amp;&#39;</span> <span class="ow">in</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[:</span> <span class="n">i</span><span class="p">]]:</span>
                            <span class="n">insert_at</span> <span class="o">=</span> <span class="n">child_inds</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="n">flip</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="c1"># sequence break or multiple stems</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s1">&#39;&amp;&#39;</span> <span class="ow">or</span>
                            <span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s1">&#39;(&#39;</span> 
                             <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">label</span><span class="o">==</span><span class="s1">&#39;(&#39;</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">[:</span> <span class="n">i</span><span class="p">]))):</span>
                        <span class="n">connect_down</span> <span class="o">=</span> <span class="n">Motif</span><span class="p">(</span><span class="n">Strand</span><span class="p">(</span><span class="s1">&#39;â”€â”€&#39;</span><span class="p">),</span>
                                            <span class="n">Strand</span><span class="p">(</span><span class="s1">&#39;â•®&#39;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span>
                                            <span class="n">Strand</span><span class="p">(</span><span class="s1">&#39;â•­&#39;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">direction</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                                            <span class="p">)</span>
                        <span class="n">connect_up</span> <span class="o">=</span> <span class="n">Motif</span><span class="p">(</span><span class="n">Strand</span><span class="p">(</span><span class="s1">&#39;â”‚â”‚â•°â”€&#39;</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                                        <span class="n">Strand</span><span class="p">(</span><span class="s1">&#39;â•°&#39;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">direction</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                                        <span class="p">)</span>
                        <span class="k">if</span> <span class="n">child_inds</span><span class="p">:</span>
                            <span class="n">insert_connect</span> <span class="o">=</span> <span class="n">child_inds</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">insert_connect</span> <span class="o">=</span> <span class="n">current_index</span>

                        <span class="c1"># insert the top connector</span>
                        <span class="n">origami</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">insert_connect</span><span class="p">,</span> <span class="n">connect_down</span><span class="p">)</span>

                        <span class="n">shift_x</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">m</span><span class="o">.</span><span class="n">num_char</span> 
                                            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">origami</span><span class="p">[</span><span class="n">insert_connect</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                                                             <span class="p">:</span><span class="n">insert_connect</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span>

                        <span class="n">connect_up</span><span class="o">.</span><span class="n">shift</span><span class="p">((</span><span class="n">shift_x</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                        <span class="n">origami</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">connect_up</span><span class="p">])</span>

                        <span class="c1"># increment the y index</span>
                        <span class="n">current_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span> 
                        <span class="c1"># set the x index to the end of the line</span>
                        <span class="n">current_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">origami</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> 

                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">insert_connect</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">current_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                            <span class="c1"># add the vertical connector</span>
                            <span class="n">origami</span><span class="o">.</span><span class="n">insert</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                            <span class="n">Motif</span><span class="p">(</span><span class="n">Strand</span><span class="p">(</span><span class="s1">&#39;â”‚&#39;</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                                                  <span class="n">Strand</span><span class="p">(</span><span class="s1">&#39;â”‚&#39;</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> 
                                                         <span class="n">start</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                                                  <span class="p">)</span><span class="o">.</span><span class="n">shift</span><span class="p">((</span><span class="n">shift_x</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                                           <span class="p">)</span>
                            <span class="c1"># shift all the motifs until you reach the first connector</span>
                            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">origami</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]:</span>
                                <span class="n">m</span><span class="o">.</span><span class="n">shift</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                                <span class="k">if</span> <span class="s1">&#39;â”‚â”‚â•°â”€&#39;</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span>
                                    <span class="k">break</span>

                    <span class="k">if</span> <span class="n">insert_at</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">insert_at</span> <span class="o">=</span> <span class="n">current_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        
                    <span class="n">child_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">insert_at</span><span class="p">)</span>
                    <span class="n">recursive_build_origami</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> 
                                            <span class="n">insert_at</span><span class="o">=</span><span class="n">insert_at</span><span class="p">,</span> 
                                            <span class="n">flip</span><span class="o">=</span><span class="n">flip</span><span class="p">)</span>

                <span class="c1"># this could not work in the case a stem doesn&#39;t end with at least</span>
                <span class="c1"># one unpaired nucleotide, but that dooes never happen in natural</span>
                <span class="c1"># structures, so we can ignore this case</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">children</span> <span class="ow">or</span> <span class="n">c</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span><span class="s1">&#39;&amp;&#39;</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
                    <span class="n">origami</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Motif</span><span class="p">(</span><span class="n">Strand</span><span class="p">(</span><span class="s1">&#39;â•®â”‚â•¯&#39;</span><span class="p">)))</span>
                    <span class="n">current_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1"># decrement the x index</span>

        <span class="c1"># call the recursive function</span>
        <span class="n">recursive_build_origami</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="c1"># get the motif from the origami object</span>
        <span class="n">motif</span> <span class="o">=</span> <span class="n">origami</span><span class="o">.</span><span class="n">assembled</span>

        <span class="c1">### ADD THE PSEUDOKNOTS ###</span>
        <span class="n">seq_offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># dictionary with index as key and pseudoknot id as value</span>
        <span class="n">full_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">pair_map</span> <span class="o">=</span> <span class="n">dot_bracket_to_pair_map</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>

        <span class="c1"># iterate over the  subsequences</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">struct</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)):</span>
            <span class="n">new_pk_info</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;ind_fwd&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;dE&#39;</span><span class="p">:</span> <span class="p">[]}</span>
            <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ss_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span>

            <span class="c1"># iterate over the subsequences structure</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ss_len</span><span class="p">:</span>
                <span class="n">sym</span> <span class="o">=</span> <span class="n">struct</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

                <span class="c1"># found pseudoknot</span>
                <span class="k">if</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39;.()&#39;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">seq_offset</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">full_map</span><span class="p">:</span>
                    <span class="c1"># get the length of the pseudoknot</span>
                    <span class="n">length</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">while</span> <span class="n">struct</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">length</span><span class="p">]</span> <span class="o">==</span> <span class="n">sym</span><span class="p">:</span>
                        <span class="n">length</span> <span class="o">+=</span> <span class="mi">1</span>
                    
                    <span class="c1"># get the pseudoknot id of get a new one</span>
                    <span class="k">if</span> <span class="n">pair_map</span><span class="p">[</span><span class="n">seq_offset</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="ow">in</span> <span class="n">full_map</span><span class="p">:</span>
                        <span class="n">pk_id</span> <span class="o">=</span> <span class="n">full_map</span><span class="p">[</span><span class="n">pair_map</span><span class="p">[</span><span class="n">seq_offset</span> <span class="o">+</span> <span class="n">j</span><span class="p">]]</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">full_map</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
                        <span class="n">pk_id</span> <span class="o">=</span> <span class="s1">&#39;100_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;-1&#39;</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    
                    <span class="c1"># add the pseudoknot to the motif</span>
                    <span class="n">new_pk_info</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pk_id</span><span class="p">)</span>
                    <span class="n">new_pk_info</span><span class="p">[</span><span class="s1">&#39;ind_fwd&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">seq_offset</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">seq_offset</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="n">length</span><span class="p">)</span>
                    <span class="c1"># update the full map</span>
                    <span class="n">full_map</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">pk_id</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">})</span>
                        
                    <span class="n">new_pk_info</span><span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pk_energy</span><span class="p">)</span>
                    <span class="n">new_pk_info</span><span class="p">[</span><span class="s1">&#39;dE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pk_denergy</span><span class="p">)</span>
                    <span class="n">j</span> <span class="o">+=</span> <span class="n">length</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># add the pseudoknots info to the strand</span>
            <span class="n">motif</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">pk_info</span> <span class="o">=</span> <span class="n">new_pk_info</span>
            <span class="n">seq_offset</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;lock_coords&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">replace_all_strands</span><span class="p">(</span><span class="n">motif</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span></div>


<div class="viewcode-block" id="Motif.from_text">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif.from_text">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_text</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">motif_text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Motif&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a Motif object from a text string representing a motif sketch.</span>
<span class="sd">        Each Strand is read starting from the `5` symbol. If you want to add the 5&#39; </span>
<span class="sd">        terminal symbol, start the strand with `55`. Only one symbol should be placed</span>
<span class="sd">        next to the `5` start of the strand in order to guess the right direction.</span>
<span class="sd">        Alternatively, you can use symbols `^v&gt;&lt;` to start a strand and indicate </span>
<span class="sd">        the start direction (up, down, right, left); in this case you can place</span>
<span class="sd">        multiple symbols next to the start symbol.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        motif_text : str</span>
<span class="sd">            The motif structure in text format.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Additional arguments to pass to the Motif constructor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Motif</span>
<span class="sd">            The constructed Motif object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">motif_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">motif_text</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)]</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_list</span><span class="p">(</span><span class="n">motif_list</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="c1">### </span>
    <span class="c1">### STATIC METHODS</span>
    <span class="c1">###</span>

<div class="viewcode-block" id="Motif.align">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif.align">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">align</span><span class="p">(</span><span class="o">*</span><span class="n">motifs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s1">&#39;Motif&#39;</span><span class="p">],</span> 
              <span class="n">axis</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> 
              <span class="n">extend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
              <span class="n">align_junctions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
              <span class="n">align_to</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;first&quot;</span><span class="p">,</span> <span class="s2">&quot;last&quot;</span><span class="p">,</span> <span class="s2">&quot;center&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;first&quot;</span><span class="p">,</span>
              <span class="n">return_shifts</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
              <span class="o">**</span><span class="n">kwargs</span>
              <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="s1">&#39;Motif&#39;</span><span class="p">]</span> <span class="o">|</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="s1">&#39;Motif&#39;</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Align motifs along a given axis by shifting them (without concatenating).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *motifs : List[Motif]</span>
<span class="sd">            List of motifs to align.</span>
<span class="sd">        axis : int, default 1</span>
<span class="sd">            The numpy axis along which motifs are aligned </span>
<span class="sd">            (1 for horizontal, 0 for vertical).</span>
<span class="sd">        extend : bool, default False</span>
<span class="sd">            If True, junctions are extended to accommodate the shift.</span>
<span class="sd">        align_junctions : Optional[List[Tuple[int, int]]], default None</span>
<span class="sd">            List of tuples specifying which junctions to align.</span>
<span class="sd">        align_to : str, default &quot;first&quot;</span>
<span class="sd">            Specifies how to align the motifs. Options: &quot;first&quot;, &quot;last&quot;, &quot;center&quot;.</span>
<span class="sd">            &quot;first&quot; aligns the first junction of the first motif with the first junction</span>
<span class="sd">            of the second motif. &quot;last&quot; aligns the last junction of the first motif</span>
<span class="sd">            with the last junction of the second motif. &quot;center&quot; aligns the center</span>
<span class="sd">            of the first motif with the center of the second motif.</span>
<span class="sd">        return_shifts : bool, default False</span>
<span class="sd">            If True, returns the shifts applied to each motif during alignment,</span>
<span class="sd">            along with the aligned motifs (useful for Origami alignment).</span>
<span class="sd">            If False, only the aligned motifs are returned.</span>
<span class="sd">        **kwargs : dict </span>
<span class="sd">            Parse if calling the motifs list explicitly.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[Motif]</span>
<span class="sd">            The list of aligned motifs.</span>
<span class="sd">        List[Tuple[int, int]], optional</span>
<span class="sd">            The list of shifts applied to each motif during alignment.</span>
<span class="sd">            Only returned if return_shifts is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">### get the alignment direction</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">direction</span> <span class="o">=</span> <span class="n">Position</span><span class="p">((</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="ow">not</span> <span class="n">axis</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2"> is not a valid value for the axis parameter.&quot;</span>
                             <span class="s2">&quot; The axis parameter must be 0 or 1&quot;</span><span class="p">)</span>
        
        <span class="c1"># the direction to shift is the opposite of the direction of the axis</span>
        <span class="n">shift_direction</span> <span class="o">=</span> <span class="n">Position</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="ow">not</span> <span class="n">axis</span><span class="p">),</span> <span class="n">axis</span><span class="p">))</span>

        <span class="c1">### check alignment type</span>
        <span class="k">if</span> <span class="n">align_to</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;first&quot;</span><span class="p">,</span> <span class="s2">&quot;last&quot;</span><span class="p">,</span> <span class="s2">&quot;center&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">align_to</span><span class="si">}</span><span class="s2"> is not a valid value for the align_to&quot;</span>
                             <span class="s2">&quot;parameter. The align_to parameter must be&quot;</span>
                             <span class="s1">&#39; &quot;first&quot;, &quot;last&quot; or &quot;center&quot;&#39;</span><span class="p">)</span>

        <span class="c1">### check if the motifs are of the right type</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">motifs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> 
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">motifs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">)</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">motifs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Motif</span><span class="p">)):</span>
            <span class="c1"># an iterable of motifs is passed</span>
            <span class="n">motifs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">motifs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">extra</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;motifs&#39;</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">()))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extra</span><span class="p">,</span> <span class="n">Motif</span><span class="p">):</span>
            <span class="n">motifs</span> <span class="o">+=</span> <span class="p">(</span><span class="n">extra</span><span class="p">,)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extra</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">motifs</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">extra</span><span class="p">)</span>
        
        <span class="c1"># check if all the motifs are of type Motif</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Motif</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">motifs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All the motifs must be of type Motif.&quot;</span><span class="p">)</span>

        <span class="c1"># if shifts are requested, save them</span>
        <span class="k">if</span> <span class="n">return_shifts</span><span class="p">:</span>
            <span class="n">shifts</span> <span class="o">=</span> <span class="p">[</span><span class="n">Position</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">motifs</span><span class="p">]</span>

        <span class="c1">### align all the motifs</span>
        <span class="n">ind1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ind2</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">n_motifs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">motifs</span><span class="p">)</span>
        <span class="c1"># start with the assumption that all the motifs are connected</span>
        <span class="n">connected_motifs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_motifs</span> 
        
        <span class="k">while</span> <span class="n">ind2</span> <span class="o">&lt;</span> <span class="n">n_motifs</span><span class="p">:</span> <span class="c1"># stop when the second motif is the last one</span>
            <span class="n">m1</span> <span class="o">=</span> <span class="n">motifs</span><span class="p">[</span><span class="n">ind1</span><span class="p">]</span>
            <span class="n">m2</span> <span class="o">=</span> <span class="n">motifs</span><span class="p">[</span><span class="n">ind2</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">align_junctions</span> <span class="ow">and</span> <span class="n">align_junctions</span><span class="p">[</span><span class="n">ind1</span><span class="p">]:</span>
                <span class="c1"># align the junction with the given index</span>
                <span class="n">junct_ind1</span><span class="p">,</span> <span class="n">junct_ind2</span> <span class="o">=</span> <span class="n">align_junctions</span><span class="p">[</span><span class="n">ind1</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># align the first junction of the first motif </span>
                <span class="c1"># with the first junction of the second motif</span>
                <span class="n">junct_ind1</span><span class="p">,</span> <span class="n">junct_ind2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="c1"># by default align the first junction</span>

                <span class="k">if</span> <span class="n">align_to</span> <span class="o">==</span> <span class="s2">&quot;last&quot;</span><span class="p">:</span>
                    <span class="n">junct_ind1</span><span class="p">,</span> <span class="n">junct_ind2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>

            <span class="n">junctions1</span> <span class="o">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">junctions</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span>
            <span class="n">junctions2</span> <span class="o">=</span> <span class="n">m2</span><span class="o">.</span><span class="n">junctions</span><span class="p">[</span><span class="o">-</span><span class="n">direction</span><span class="p">]</span>

            <span class="c1">### calculate the shift of the two motifs </span>
            <span class="c1"># and shift the motif with the lower junction</span>
            <span class="k">if</span> <span class="n">align_to</span> <span class="o">==</span> <span class="s2">&quot;center&quot;</span><span class="p">:</span>
                <span class="c1"># if align_to is center align to the center of the motifs</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">((</span><span class="n">m1</span><span class="o">.</span><span class="n">max_pos</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="n">m1</span><span class="o">.</span><span class="n">min_pos</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>  
                         <span class="o">-</span> <span class="p">(</span><span class="n">m2</span><span class="o">.</span><span class="n">max_pos</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="n">m2</span><span class="o">.</span><span class="n">min_pos</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>

            <span class="k">elif</span> <span class="p">(</span><span class="n">junctions1</span> 
                    <span class="ow">and</span> <span class="n">junctions2</span> 
                    <span class="ow">and</span> <span class="n">junct_ind1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">junctions1</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">junct_ind2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">junctions2</span><span class="p">)):</span>
                <span class="c1"># if junctions are detected, calculate the shift based on the junctions</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="n">junctions1</span><span class="p">[</span><span class="n">junct_ind1</span><span class="p">][</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="n">junctions2</span><span class="p">[</span><span class="n">junct_ind2</span><span class="p">][</span><span class="n">axis</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span> <span class="c1"># nothing to align, the motifs are not connected</span>
                <span class="n">connected_motifs</span><span class="p">[</span><span class="n">ind1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># mark the first motif as not connected</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">shift_pos</span> <span class="o">=</span> <span class="n">shift_direction</span> <span class="o">*</span> <span class="n">shift</span>
            
            <span class="k">if</span> <span class="n">shift</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># shift only the newly appended motif</span>
                <span class="n">m2</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">shift_pos</span><span class="p">,</span> <span class="n">extend</span><span class="o">=</span><span class="n">extend</span><span class="p">)</span>
                
                <span class="c1"># update the shifts</span>
                <span class="k">if</span> <span class="n">return_shifts</span><span class="p">:</span>
                    <span class="n">shifts</span><span class="p">[</span><span class="n">ind2</span><span class="p">]</span> <span class="o">=</span> <span class="n">shifts</span><span class="p">[</span><span class="n">ind2</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift_pos</span>

            <span class="k">elif</span> <span class="n">shift</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">shift_pos</span> <span class="o">=</span> <span class="o">-</span><span class="n">shift_pos</span>
                <span class="c1"># shift the left motif and all the previous one if they are connected</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ind1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">connected_motifs</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                        <span class="k">break</span>
                        
                    <span class="n">motifs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">shift_pos</span><span class="p">,</span> <span class="n">extend</span><span class="o">=</span><span class="n">extend</span><span class="p">)</span>
                        
                    <span class="c1"># update the shifts</span>
                    <span class="k">if</span> <span class="n">return_shifts</span><span class="p">:</span>
                        <span class="n">shifts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">shifts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift_pos</span>

            <span class="c1"># update the indices</span>
            <span class="n">ind1</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ind2</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">return_shifts</span><span class="p">:</span>
            <span class="c1"># if the shifts are requested, return them</span>
            <span class="k">return</span> <span class="n">motifs</span><span class="p">,</span> <span class="n">shifts</span>
        
        <span class="c1"># if the shifts are not requested, return the motifs</span>
        <span class="k">return</span> <span class="n">motifs</span></div>


<div class="viewcode-block" id="Motif.copy_strands_preserve_blocks">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif.copy_strands_preserve_blocks">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">copy_strands_preserve_blocks</span><span class="p">(</span><span class="n">strands</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;Strand&quot;</span><span class="p">],</span> 
                                     <span class="n">motif</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Motif&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                                     <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;Strand&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy a list of strands while preserving strand blocks.</span>
<span class="sd">        Ensures that strands that belong to the same motif remain linked together.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strands : list of Strand</span>
<span class="sd">            The list of strands to be copied.</span>
<span class="sd">        motif : Motif, optional</span>
<span class="sd">            If provided, associates the strands with the given motif and registers </span>
<span class="sd">            callback functions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of Strand</span>
<span class="sd">            A list of copied strands.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># IMPORTANT: keep strand that are part of the same motif linked</span>
        <span class="c1"># get the set of strands block id</span>
        <span class="n">motifs_id</span> <span class="o">=</span> <span class="p">{</span><span class="nb">id</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">strands_block</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strands</span><span class="p">}</span> 
        <span class="c1"># for each strands block, make a new one and link to the old id</span>
        <span class="n">new_motifs_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">StrandsBlock</span><span class="p">()</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">motifs_id</span><span class="p">}</span> 
        
        <span class="n">strands_copy</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># copy all strands</span>
        <span class="k">for</span> <span class="n">strand</span> <span class="ow">in</span> <span class="n">strands</span><span class="p">:</span>
            <span class="c1"># check that the strands are in the strand class</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strand</span><span class="p">,</span> <span class="n">Strand</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">strand</span><span class="si">}</span><span class="s2"> is not a Strand object.&quot;</span><span class="p">)</span>
            <span class="c1"># collect the new strands block</span>
            <span class="n">new_strands_block</span> <span class="o">=</span> <span class="n">new_motifs_dict</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">strand</span><span class="o">.</span><span class="n">strands_block</span><span class="p">)]</span> 
            <span class="c1"># copy the strand and add the callback</span>
            <span class="k">if</span> <span class="n">motif</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">copied</span> <span class="o">=</span> <span class="n">strand</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">callback</span> <span class="o">=</span> <span class="n">motif</span><span class="o">.</span><span class="n">_updated_strands</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">copied</span> <span class="o">=</span> <span class="n">strand</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">strands_copy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copied</span><span class="p">)</span>
            <span class="n">new_strands_block</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">copied</span><span class="p">)</span> <span class="c1"># add the origami to the new strands block</span>
        <span class="k">return</span> <span class="n">strands_copy</span></div>


<div class="viewcode-block" id="Motif.get_sequential_shift">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif.get_sequential_shift">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_sequential_shift</span><span class="p">(</span><span class="n">motifs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s1">&#39;Motif&#39;</span><span class="p">],</span> 
                             <span class="o">*</span><span class="n">args</span><span class="p">,</span> 
                             <span class="n">axis</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> 
                             <span class="n">position_based</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the shift needed to align motifs sequentially.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        motifs : List[Motif]</span>
<span class="sd">            List of motifs to align.</span>
<span class="sd">        *args: List[Motif]</span>
<span class="sd">            Additional motifs to align.</span>
<span class="sd">        axis : int, default 1</span>
<span class="sd">            The numpy axis along which the shift is computed </span>
<span class="sd">            (1 for horizontal, 0 for vertical).</span>
<span class="sd">        position_based : bool, default True</span>
<span class="sd">            If True, the shift is calculated based on motif positions</span>
<span class="sd">            rather than junctions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[int]</span>
<span class="sd">            A list of shift integers for each motif along the axis.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        m1:</span>
<span class="sd">            --NN--</span>
<span class="sd">              ::</span>
<span class="sd">            --NN--</span>
<span class="sd">        m2:</span>
<span class="sd">            --SK--</span>
<span class="sd">              ::</span>
<span class="sd">            --SK--</span>
<span class="sd">        Resulting shift: 2</span>
<span class="sd">            [0, 2]</span>
<span class="sd">        To have:</span>
<span class="sd">            --NN----SK--</span>
<span class="sd">              ::    ::  </span>
<span class="sd">            --NN----SK--</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">motifs</span><span class="p">,</span> <span class="n">Motif</span><span class="p">):</span>
            <span class="n">motifs</span> <span class="o">=</span> <span class="p">[</span><span class="n">motifs</span><span class="p">]</span>
        <span class="c1"># put the motifs in a list and remove the empty motifs</span>
        <span class="n">motifs</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">motifs</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="k">if</span> <span class="n">m</span><span class="p">]</span>

        <span class="c1"># trick to handle all the axis at once</span>
        <span class="n">x_pos</span> <span class="o">=</span> <span class="n">axis</span>
        <span class="n">y_pos</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="ow">not</span> <span class="n">axis</span><span class="p">)</span>

        <span class="n">shifts</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">current_shift</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">m1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">motifs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">m2</span> <span class="o">=</span> <span class="n">motifs</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># calculate the shift based on the positions </span>
            <span class="k">if</span> <span class="n">position_based</span><span class="p">:</span> 
                <span class="n">max_pos_m1</span> <span class="o">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">max_pos</span><span class="p">[</span><span class="n">y_pos</span><span class="p">]</span>
                <span class="n">min_pos_m2</span> <span class="o">=</span> <span class="n">m2</span><span class="o">.</span><span class="n">min_pos</span><span class="p">[</span><span class="n">y_pos</span><span class="p">]</span>

            <span class="c1"># calculate the shift based on the junctions</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">m1_junct</span> <span class="o">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">junctions</span>
                <span class="n">m2_junct</span> <span class="o">=</span> <span class="n">m2</span><span class="o">.</span><span class="n">junctions</span>
                
                <span class="c1"># if the junctions are detected, calculate the shift </span>
                <span class="c1"># based on the junctions</span>
                <span class="n">junc_dir</span> <span class="o">=</span> <span class="n">Position</span><span class="p">((</span><span class="n">x_pos</span><span class="p">,</span> <span class="n">y_pos</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">m1_junct</span><span class="p">[</span><span class="n">junc_dir</span><span class="p">]</span> <span class="ow">and</span> <span class="n">m2_junct</span><span class="p">[</span><span class="o">-</span><span class="n">junc_dir</span><span class="p">]:</span>
                    <span class="n">max_pos_m1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">pos</span><span class="p">[</span><span class="n">y_pos</span><span class="p">]</span> <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">m1_junct</span><span class="p">[</span><span class="n">junc_dir</span><span class="p">]))</span>
                    <span class="n">min_pos_m2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">pos</span><span class="p">[</span><span class="n">y_pos</span><span class="p">]</span> <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">m2_junct</span><span class="p">[</span><span class="o">-</span><span class="n">junc_dir</span><span class="p">]))</span>
                
                <span class="k">else</span><span class="p">:</span> <span class="c1"># no junctions, just concatenate the motifs</span>
                    <span class="n">max_pos_m1</span> <span class="o">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">max_pos</span><span class="p">[</span><span class="n">y_pos</span><span class="p">]</span>
                    <span class="n">min_pos_m2</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># update the shift</span>
            <span class="n">current_shift</span> <span class="o">+=</span> <span class="n">max_pos_m1</span> <span class="o">-</span> <span class="n">min_pos_m2</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">shifts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_shift</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">shifts</span></div>


<div class="viewcode-block" id="Motif.join_strands">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif.join_strands">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">join_strands</span><span class="p">(</span><span class="n">strands</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s1">&#39;Strand&#39;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="s1">&#39;Strand&#39;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempt to join consecutive strands and return the list of joined strands.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strands : List[Strand]</span>
<span class="sd">            The list of strands to be joined.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[Strand]</span>
<span class="sd">            The list of joined strands.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># remove the empty strands</span>
        <span class="n">strands</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strands</span> <span class="k">if</span> <span class="n">s</span><span class="p">]</span> 
        
        <span class="c1"># ordering strand is:</span>
        <span class="c1"># - the strands with 5&#39; end</span>
        <span class="c1"># - strand with the lowest y start position</span>
        <span class="c1"># - strand with the lowest x start position</span>
        <span class="n">strands</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">strands</span><span class="p">,</span> 
                         <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;5&#39;</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">strand</span><span class="p">),</span> <span class="o">*</span><span class="n">s</span><span class="o">.</span><span class="n">start</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    
        <span class="c1"># Comments for coders: I tried different ways to join the strands, </span>
        <span class="c1"># especially building a graph of joinable strands then using Depth First Search</span>
        <span class="c1"># to join the adjacent strands; but this version of the code is faster</span>

        <span class="n">joined_strands</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ind1</span><span class="p">,</span> <span class="n">s1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">strands</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="c1"># if the strand is empty, or is already joined skip it</span>
            <span class="k">if</span> <span class="n">ind1</span> <span class="ow">in</span> <span class="n">joined_strands</span><span class="p">:</span> 
                <span class="k">continue</span> 

            <span class="c1"># join the strand with the consecutive strands </span>
            <span class="c1"># until no more strands are joined</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">current_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">joined_strands</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ind2</span><span class="p">,</span> <span class="n">s2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">strands</span><span class="p">):</span> 

                    <span class="c1"># skip s2 is the same strand or already joined</span>
                    <span class="k">if</span> <span class="n">ind1</span> <span class="o">==</span> <span class="n">ind2</span> <span class="ow">or</span> <span class="n">ind2</span> <span class="ow">in</span> <span class="n">joined_strands</span><span class="p">:</span> 
                        <span class="k">continue</span> 

                    <span class="c1"># skip if the motifs are not joinable for sure</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">((</span><span class="n">s1</span><span class="o">.</span><span class="n">prec_pos</span><span class="p">,</span>
                                <span class="n">s1</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                                <span class="n">s1</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
                                <span class="n">s1</span><span class="o">.</span><span class="n">next_pos</span><span class="p">,</span>
                                <span class="n">s2</span><span class="o">.</span><span class="n">prec_pos</span><span class="p">,</span>
                                <span class="n">s2</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                                <span class="n">s2</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
                                <span class="n">s2</span><span class="o">.</span><span class="n">next_pos</span><span class="p">)))</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                        <span class="k">continue</span>
                    
                    <span class="c1"># try to join the strands</span>
                    <span class="n">joined</span> <span class="o">=</span> <span class="n">Strand</span><span class="o">.</span><span class="n">join_strands</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> 

                    <span class="c1"># the strands are joined</span>
                    <span class="k">if</span> <span class="n">joined</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
                        <span class="c1"># add the index of strand2 to the joined strands</span>
                        <span class="n">joined_strands</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ind2</span><span class="p">)</span> 
                        <span class="c1"># replace the first strand with the joined strand</span>
                        <span class="n">strands</span><span class="p">[</span><span class="n">ind1</span><span class="p">]</span> <span class="o">=</span> <span class="n">joined</span> 
                        <span class="c1"># update the first strand</span>
                        <span class="n">s1</span> <span class="o">=</span> <span class="n">joined</span> 

                <span class="c1"># if nothing is joined, break the loop</span>
                <span class="k">if</span> <span class="n">current_len</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">joined_strands</span><span class="p">):</span>
                    <span class="k">break</span>

        <span class="c1"># return the strands excluded the joined ones</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">strands</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">joined_strands</span><span class="p">]</span> </div>


<div class="viewcode-block" id="Motif.trace">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif.trace">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="n">motif_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> 
              <span class="n">pos</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> 
              <span class="n">direction</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> 
              <span class="n">limits</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trace strands in a motif representation in a recursive manner.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        motif_list : list of str</span>
<span class="sd">            The list of strings of the motif sketch.</span>
<span class="sd">        pos : tuple of int</span>
<span class="sd">            The starting position.</span>
<span class="sd">        direction : tuple of int</span>
<span class="sd">            The tracing direction.</span>
<span class="sd">        limits : tuple of int</span>
<span class="sd">            The boundary limits.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            The traced strand sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pos is a tuple (x,y) of the character we are considering</span>
        <span class="c1"># so it is a tuple (char_ind, line_ind)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># We reached an adge</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>
        
        <span class="c1"># Read the new symbol</span>
        <span class="n">sym</span> <span class="o">=</span> <span class="n">motif_list</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span>
        
        <span class="c1"># Terminal symbols</span>
        <span class="k">if</span> <span class="n">sym</span> <span class="o">==</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sym</span>
        <span class="k">elif</span> <span class="n">sym</span> <span class="o">==</span> <span class="s1">&#39; &#39;</span> <span class="ow">or</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">accept_symbol</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>
            
        <span class="c1"># Direction turns</span>
        <span class="k">elif</span> <span class="n">sym</span> <span class="ow">in</span> <span class="s2">&quot;â•°â•®</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">:</span> <span class="c1"># reverse the tuple</span>
            <span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">sym</span> <span class="ow">in</span> <span class="s2">&quot;â•­â•¯/&quot;</span><span class="p">:</span> <span class="c1"># reverse the tuple and change sign</span>
            <span class="n">direction</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span> <span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span> <span class="n">direction</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Error</span>
        <span class="k">elif</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">bp_symbols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MotifStructureError</span><span class="p">(</span><span class="s2">&quot;The strand leads to a base pairing&quot;</span><span class="p">)</span>

        <span class="c1"># Go to the next position</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">direction</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Recursive call</span>
        <span class="k">return</span> <span class="n">sym</span> <span class="o">+</span> <span class="n">Motif</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">motif_list</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">limits</span><span class="p">)</span></div>


    <span class="c1">### </span>
    <span class="c1">### PROTECTED METHODS</span>
    <span class="c1">###</span>

    <span class="k">def</span> <span class="nf">_calculate_basepair</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate and store base pairings in the `_basepair` attribute.</span>
<span class="sd">        The method determines base pairing by identifying complementary bases </span>
<span class="sd">        that are positioned one step away (horizontally or vertically). The </span>
<span class="sd">        base pairing dictionary (using positions as key/value) is stored in </span>
<span class="sd">        the `_basepair` attribute as a Basepair object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">basepair</span> <span class="o">=</span> <span class="n">BasePair</span><span class="p">(</span><span class="n">callback</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_updated_basepair</span><span class="p">)</span>
        <span class="n">pos_to_ind</span> <span class="o">=</span> <span class="p">{</span><span class="n">pos</span><span class="p">:</span> <span class="n">ind</span> <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_positions</span><span class="p">)}</span>
        <span class="n">sequence</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">pos1</span><span class="p">,</span> <span class="n">ind1</span> <span class="ow">in</span> <span class="n">pos_to_ind</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">base1</span> <span class="o">=</span> <span class="n">sequence</span><span class="p">[</span><span class="n">ind1</span><span class="p">]</span>
            <span class="c1"># skip already paired pos</span>
            <span class="k">if</span> <span class="n">pos1</span> <span class="ow">in</span> <span class="n">basepair</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># control if there is a complementary base in all the directions </span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">Direction</span><span class="p">:</span>
                <span class="c1"># calculate the second position</span>
                <span class="n">pos2</span> <span class="o">=</span> <span class="n">pos1</span> <span class="o">+</span> <span class="n">d</span> <span class="o">*</span> <span class="mi">2</span> 
                
                <span class="c1"># skip the positions already paired or not in the base map</span>
                <span class="k">if</span> <span class="n">pos2</span> <span class="ow">in</span> <span class="n">basepair</span> <span class="ow">or</span> <span class="n">pos2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pos_to_ind</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># if the basepair position is already taken, skip</span>
                <span class="n">bp_pos</span> <span class="o">=</span> <span class="n">pos1</span> <span class="o">+</span> <span class="n">d</span>
                <span class="k">if</span> <span class="n">bp_pos</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># check the bases can pair</span>
                <span class="n">base2</span> <span class="o">=</span> <span class="n">sequence</span><span class="p">[</span><span class="n">pos_to_ind</span><span class="p">[</span><span class="n">pos2</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">base2</span> <span class="ow">in</span> <span class="n">base_pairing</span><span class="p">[</span><span class="n">base1</span><span class="p">]:</span>
                    <span class="n">basepair</span><span class="p">[</span><span class="n">Position</span><span class="p">(</span><span class="n">pos1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Position</span><span class="p">(</span><span class="n">pos2</span><span class="p">)</span>
                    <span class="k">break</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_basepair</span> <span class="o">=</span> <span class="n">basepair</span>

    <span class="k">def</span> <span class="nf">_calculate_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Calculate the 2D properties of the strand.</span>
<span class="sd">        This function calculates the properties:</span>
<span class="sd">            - positions</span>
<span class="sd">            - seq_positions</span>
<span class="sd">            - max_pos</span>
<span class="sd">            - min_pos</span>
<span class="sd">            - junctions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">### initialize the variables</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="p">()</span>
        <span class="n">seq_positions</span> <span class="o">=</span> <span class="p">()</span>
        <span class="n">max_pos</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">min_pos</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)]</span>
        <span class="c1">### initialize the junctions</span>
        <span class="n">junctions_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">direct</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">direct</span> <span class="ow">in</span> <span class="n">Direction</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">positions</span> <span class="o">+=</span> <span class="n">s</span><span class="o">.</span><span class="n">positions</span>

            <span class="n">seq_dir</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">directionality</span> <span class="o">==</span> <span class="s1">&#39;53&#39;</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">seq_positions</span> <span class="o">+=</span> <span class="n">s</span><span class="o">.</span><span class="n">_seq_positions</span><span class="p">[::</span><span class="n">seq_dir</span><span class="p">]</span>

            <span class="c1"># update MAX/MIN positions</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">_max_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">max_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">_max_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">_max_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">max_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">_max_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">_min_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">min_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">_min_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">_min_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">min_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">_min_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># skip if the the start is &#39;5&#39; or &#39;3&#39; and the strand is not just the symbol</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39;35&#39;</span><span class="p">:</span>
                <span class="c1"># invert the start direction to have the direction of the junction </span>
                <span class="n">junctions_dict</span><span class="p">[</span><span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">direction</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> 
                
            <span class="c1"># skip if the the end is &#39;5&#39; or &#39;3&#39; and the strand is not just the symbol</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39;35&#39;</span><span class="p">:</span> 
                <span class="n">junctions_dict</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">end_direction</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>

        <span class="c1">### order the junctions</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">junctions_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># order the bottom/top junctions</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Direction</span><span class="o">.</span><span class="n">DOWN</span><span class="p">,</span> <span class="n">Direction</span><span class="o">.</span><span class="n">UP</span><span class="p">):</span>
                <span class="n">val</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span> <span class="c1"># order the junctions in growing x and y</span>
            <span class="c1"># order the left/right junctions</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Direction</span><span class="o">.</span><span class="n">LEFT</span><span class="p">,</span> <span class="n">Direction</span><span class="o">.</span><span class="n">RIGHT</span><span class="p">):</span>
                <span class="n">val</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pos</span> <span class="p">:</span> <span class="n">pos</span><span class="o">.</span><span class="n">swap_xy</span><span class="p">())</span> <span class="c1"># order in growing y and x</span>
            
        <span class="c1">#### convert the junctions to tuple</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_junctions</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">junctions_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># save the other positional properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span> <span class="o">=</span> <span class="n">positions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_seq_positions</span> <span class="o">=</span> <span class="n">seq_positions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_pos</span> <span class="o">=</span> <span class="n">Position</span><span class="p">(</span><span class="n">max_pos</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_min_pos</span> <span class="o">=</span> <span class="n">Position</span><span class="p">((</span><span class="n">c</span> <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">min_pos</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_check_addition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                        <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Motif&quot;</span><span class="p">,</span> 
                        <span class="n">direction</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Position</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether two motifs can be added together in a given direction.</span>
<span class="sd">        The function ensures that the motifs have compatible junctions for addition.</span>
<span class="sd">        It raises an error if they cannot be added.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Motif</span>
<span class="sd">            The motif to be added.</span>
<span class="sd">        direction : tuple of int, optional</span>
<span class="sd">            The direction in which the motifs should be checked for addition.</span>
<span class="sd">            Default is Direction(1, 0) (right).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `other` is not an instance of `Motif`.</span>
<span class="sd">        MotifStructureError</span>
<span class="sd">            If the motifs do not have compatible junctions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if one of the two motifs is empty, return without error</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> 
    
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Motif</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">other</span><span class="si">}</span><span class="s1"> is not a valid type for addition&#39;</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">direction</span> <span class="o">=</span> <span class="n">Direction</span><span class="o">.</span><span class="n">RIGHT</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="p">(</span><span class="n">Direction</span><span class="p">,</span> <span class="n">Position</span><span class="p">)):</span>
            <span class="n">direction</span> <span class="o">=</span> <span class="n">Position</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>

        <span class="c1"># take the junctions of the left and right side of the motifs</span>
        <span class="n">Strand</span><span class="o">.</span><span class="n">_check_position</span><span class="p">(</span><span class="n">input_pos_dir</span> <span class="o">=</span> <span class="n">direction</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">junction1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">junctions</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span>
        <span class="n">junction2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">junctions</span><span class="p">[</span><span class="n">direction</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
        <span class="c1">### SANITY CHECKS</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">junction1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">junction2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MotifStructureError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The motifs cannot be added in the direction </span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="s2">&quot;the junctions are missing. Junctions&quot;</span> 
                <span class="sa">f</span><span class="s2">&quot; motif1: </span><span class="si">{</span><span class="n">junction1</span><span class="si">}</span><span class="s2">, Junctions motif2: </span><span class="si">{</span><span class="n">junction2</span><span class="si">}</span><span class="s2">. If you want&quot;</span> 
                <span class="s2">&quot; to concatenate the motifs, use pf.Motif.concat() method.&quot;</span><span class="p">)</span> 

    <span class="k">def</span> <span class="nf">_updated_basepair</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the base-pair dictionary when the sequence changes.</span>

<span class="sd">        This is a callback function triggered when modifications occur to the sequence</span>
<span class="sd">        or base-pair mappings, ensuring consistency in structural relationships.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments that may be passed during the update process.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function resets the dot-bracket notation representation of the motif.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># reset the dot bracket</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trigger_callbacks</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_updated_strands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the motif when the strands are changed.</span>

<span class="sd">        This is a callback function that is triggered when the strands of the motif </span>
<span class="sd">        are modified, ensuring that cached properties (e.g., structure, base pairs) </span>
<span class="sd">        remain consistent.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments that may be passed during the update process.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method resets cached attributes such as:</span>
<span class="sd">        - Sequence</span>
<span class="sd">        - Position mappings</span>
<span class="sd">        - Base-pair structures</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sequence</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_positions</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autopairing</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_basepair</span> <span class="o">=</span> <span class="n">BasePair</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updated_basepair</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trigger_callbacks</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1">### </span>
    <span class="c1">### METHODS</span>
    <span class="c1">###</span>
    
<div class="viewcode-block" id="Motif.append">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif.append">[docs]</a>
    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
               <span class="n">strand</span><span class="p">:</span> <span class="s1">&#39;Strand&#39;</span><span class="p">,</span> 
               <span class="n">join</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
               <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Motif&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append a strand to the motif.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strand : Strand</span>
<span class="sd">            The strand to be added.</span>
<span class="sd">        join : bool, default True</span>
<span class="sd">            Whether to attempt joining the new strand with existing strands.</span>
<span class="sd">        copy : bool, default False</span>
<span class="sd">            If True, a copy of the strand is appended.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Motif</span>
<span class="sd">            The updated motif.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the provided `strand` is not a `Strand` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strand</span><span class="p">,</span> <span class="n">Strand</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">strand</span><span class="si">}</span><span class="s2"> is not a Strand object.&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">strand</span> <span class="o">=</span> <span class="n">strand</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">strand</span><span class="o">.</span><span class="n">register_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_updated_strands</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">strand</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">join</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_strands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">join_strands</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_strands</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock_coords</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_strands_block</span> <span class="o">=</span> <span class="n">StrandsBlock</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strands</span><span class="p">])</span> 

        <span class="bp">self</span><span class="o">.</span><span class="n">_updated_strands</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Motif.copy">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif.copy">[docs]</a>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Motif&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the motif.</span>

<span class="sd">        This method creates a custom deep copy of the current motif, preserving </span>
<span class="sd">        its strand arrangements, base pairings, and additional attributes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        callback : callable, default None</span>
<span class="sd">            A callback function to be registered in the copied motif.</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            If the keyword &#39;deepcopy&#39; with a list of attributes names is passed,</span>
<span class="sd">            the attributes will deepcopyed instead referenced.</span>
<span class="sd">            Same for the keyword &#39;copy&#39; with a list of attributes names.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Motif or subclass</span>
<span class="sd">            A new instance of the motif or its subclass, with the same properties</span>
<span class="sd">            and attributes as the original.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_motif</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="c1"># attributes that are calculated fresh or immutable that</span>
        <span class="c1"># can be just reassigned</span>
        <span class="n">basic_properties</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;_autopairing&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;_lock_coords&#39;</span><span class="p">,</span> 
                            <span class="s1">&#39;_structure&#39;</span><span class="p">,</span> 
                            <span class="s1">&#39;_positions&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;_seq_positions&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;_max_pos&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;_min_pos&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;_sequence&#39;</span><span class="p">,</span>
                            <span class="p">}</span>
        <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">basic_properties</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">new_motif</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prop</span><span class="p">))</span>
        
        <span class="c1"># attributes that have to be teatred differently</span>
        <span class="n">avoid_to_copy</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;_basepair&#39;</span><span class="p">,</span> 
                         <span class="s1">&#39;_junctions&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;_pair_map&#39;</span><span class="p">,</span> 
                         <span class="s1">&#39;_strands_block&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;_strands&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;_callbacks&#39;</span><span class="p">,</span>
                         <span class="p">}</span>

        <span class="n">new_motif</span><span class="o">.</span><span class="n">_strands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_strands_preserve_blocks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_strands</span><span class="p">,</span>
                                                               <span class="n">new_motif</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lock_coords</span> <span class="ow">and</span> <span class="n">new_motif</span><span class="o">.</span><span class="n">_strands</span><span class="p">:</span>
            <span class="n">new_motif</span><span class="o">.</span><span class="n">_strands_block</span> <span class="o">=</span> <span class="n">new_motif</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strands_block</span>
        <span class="n">new_motif</span><span class="o">.</span><span class="n">_junctions</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_junctions</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">new_motif</span><span class="o">.</span><span class="n">_basepair</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basepair</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_motif</span><span class="o">.</span><span class="n">_pair_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pair_map</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_motif</span><span class="o">.</span><span class="n">_callbacks</span> <span class="o">=</span> <span class="p">[</span><span class="n">callback</span><span class="p">]</span> <span class="k">if</span> <span class="n">callback</span> <span class="k">else</span> <span class="p">[]</span>

        <span class="c1">### The other attributes should be freshly calculated</span>
        <span class="c1"># or immutable, so just reassign them</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="c1"># deepcopy the attribute if it is in the deepcopy list</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;deepcopy&#39;</span><span class="p">,</span> <span class="p">()):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">new_motif</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)))</span>
                <span class="k">continue</span>

            <span class="c1"># copy the attribute if it is in the copy list</span>
            <span class="k">elif</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;copy&#39;</span><span class="p">,</span> <span class="p">()):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">new_motif</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="k">continue</span>

            <span class="c1"># check if the attribute is to avoid or already copied</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">avoid_to_copy</span> <span class="ow">or</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">basic_properties</span><span class="p">:</span>
                <span class="k">continue</span>
            
            <span class="c1"># reference the attribute </span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">new_motif</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">new_motif</span></div>


<div class="viewcode-block" id="Motif.extend_junctions">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif.extend_junctions">[docs]</a>
    <span class="k">def</span> <span class="nf">extend_junctions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                         <span class="n">skip_axis</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                         <span class="n">skip_directions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Direction</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">until</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="s1">&#39;Motif&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extend the junctions of the motif in the direction of the junctions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        skip_axis: int, optional</span>
<span class="sd">            The numpy axis to skip when extending the junctions </span>
<span class="sd">            (1 for horizontal, 0 for vertical).</span>
<span class="sd">        skip_directions: List[Direction], optional</span>
<span class="sd">            The list of directions to skip when extending the junctions.</span>
<span class="sd">        until : tuple, default (None, None)</span>
<span class="sd">            The position until which to extend the junctions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Motif</span>
<span class="sd">            The motif with the extended junctions.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the axis parameter is not None, 0 or 1.</span>
<span class="sd">        MotifStructureError</span>
<span class="sd">            If there is an error in extending the junction</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">juncts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">junctions</span>
        <span class="k">if</span> <span class="n">skip_directions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">skip_directions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">skip_axis</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">skip_directions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">skip_axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="ow">not</span> <span class="n">skip_axis</span><span class="p">)))</span>
            <span class="n">skip_directions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="o">-</span><span class="n">skip_axis</span><span class="p">,</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="ow">not</span> <span class="n">skip_axis</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">skip_axis</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">skip_axis</span><span class="si">}</span><span class="s2"> is not a valid value for the axis.&quot;</span>
                             <span class="s2">&quot; You can skip the axis 0 or 1&quot;</span><span class="p">)</span>
        
        <span class="c1"># make a dictionary from positions to index</span>
        <span class="n">index_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="p">:</span> <span class="n">ind</span> <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">positions</span><span class="p">}</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">sym</span> <span class="ow">in</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;â”€&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;â”‚&#39;</span><span class="p">)):</span> <span class="c1"># consider the two axis</span>
                <span class="n">naxis</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="ow">not</span> <span class="n">axis</span><span class="p">)</span>
                <span class="n">neg_direction</span> <span class="o">=</span> <span class="n">Position</span><span class="p">((</span><span class="o">-</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span> <span class="n">naxis</span><span class="p">))</span>
                <span class="n">pos_direction</span> <span class="o">=</span> <span class="n">Position</span><span class="p">((</span><span class="n">axis</span><span class="p">,</span> <span class="n">naxis</span><span class="p">))</span> 

                <span class="k">if</span> <span class="n">neg_direction</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">skip_directions</span><span class="p">:</span>
                    <span class="c1"># consider all the junction positions in the negative direction</span>
                    <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">juncts</span><span class="p">[</span><span class="n">neg_direction</span><span class="p">]:</span> 

                        <span class="c1"># if the position is not at the minimum border</span>
                        <span class="k">if</span> <span class="n">pos</span><span class="p">[</span><span class="n">naxis</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> 
                            <span class="c1"># add a strand from the position and going to the border</span>
                            <span class="n">extend_strand</span> <span class="o">=</span> <span class="n">Strand</span><span class="p">(</span><span class="n">sym</span> <span class="o">*</span> <span class="n">pos</span><span class="p">[</span><span class="n">naxis</span><span class="p">],</span> 
                                                   <span class="n">start</span><span class="o">=</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">naxis</span><span class="p">,</span> 
                                                   <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">axis</span><span class="p">),</span>
                                                   <span class="n">direction</span><span class="o">=</span><span class="n">pos_direction</span><span class="p">)</span>
                            
                            <span class="c1"># check that the extension doesn&#39;t overlap </span>
                            <span class="c1"># with other strands</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">extend_strand</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span> 
                                            <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">index_map</span><span class="p">)):</span> 
                                <span class="c1"># get the strand at the position</span>
                                <span class="n">strand_at_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">index_map</span><span class="p">[</span><span class="n">pos</span><span class="p">]]</span> 
                                <span class="n">strand_at_pos</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">extend_strand</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">pos_direction</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">skip_directions</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">juncts</span><span class="p">[</span><span class="n">pos_direction</span><span class="p">]:</span>

                        <span class="n">strand_at_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">index_map</span><span class="p">[</span><span class="n">pos</span><span class="p">]]</span> 
                        <span class="n">max_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_pos</span><span class="p">[</span><span class="n">naxis</span><span class="p">]</span>

                        <span class="c1"># set the maximum position to the until parameter</span>
                        <span class="k">if</span> <span class="n">until</span><span class="p">[</span><span class="n">naxis</span><span class="p">]:</span> 
                            <span class="n">max_pos</span> <span class="o">=</span> <span class="n">until</span><span class="p">[</span><span class="n">naxis</span><span class="p">]</span> 

                        <span class="k">if</span> <span class="n">pos</span><span class="p">[</span><span class="n">naxis</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">max_pos</span><span class="p">:</span> 
                            <span class="c1"># add a strand from the position and going to the border,</span>
                            <span class="n">extend_strand</span> <span class="o">=</span> <span class="n">Strand</span><span class="p">(</span><span class="n">sym</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_pos</span> <span class="o">-</span> <span class="n">pos</span><span class="p">[</span><span class="n">naxis</span><span class="p">]),</span> 
                                                   <span class="n">start</span><span class="o">=</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">axis</span><span class="p">,</span> 
                                                          <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">naxis</span><span class="p">),</span> 
                                                   <span class="n">direction</span><span class="o">=</span><span class="n">pos_direction</span><span class="p">)</span>
                            
                            <span class="c1"># check that the extension doesn&#39;t overlap </span>
                            <span class="c1"># with other strands</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">extend_strand</span><span class="o">.</span><span class="n">positions</span><span class="p">)</span> 
                                            <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">index_map</span><span class="p">)):</span> 
                                <span class="n">strand_at_pos</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">extend_strand</span><span class="p">)</span>

        <span class="k">except</span> <span class="n">MotifStructureError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error in extending junction at position </span><span class="si">{</span><span class="n">pos</span><span class="si">}</span><span class="s2">. Full error:&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Motif.flip">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif.flip">[docs]</a>
    <span class="k">def</span> <span class="nf">flip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
             <span class="n">horizontally</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
             <span class="n">vertically</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
             <span class="n">strand_index</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Motif&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flip the strands of the motif horizontally and/or vertically inplace.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        horizontally : bool, default True</span>
<span class="sd">            If True, flip the strands horizontally.</span>
<span class="sd">        vertically : bool, default True</span>
<span class="sd">            If True, flip the strands vertically.</span>
<span class="sd">        strand_index : list, default None</span>
<span class="sd">            The list of indices of the strands to flip.</span>
<span class="sd">            If None, all the strands are flipped.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Motif</span>
<span class="sd">            The motif with the flipped strands.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># save the initial index of character and lines, </span>
        <span class="c1"># (it changes every time you change a strand otherwise)</span>
        <span class="n">idx_char</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_char</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">idx_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_lines</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># create new basepair dictionary in case autopairing is off</span>
        <span class="n">new_basepair_dict</span> <span class="o">=</span> <span class="n">BasePair</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">pos1</span><span class="p">,</span> <span class="n">pos2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">basepair</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">horizontally</span><span class="p">:</span>
                <span class="n">pos1</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx_char</span> <span class="o">-</span> <span class="n">pos1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># flip the horizontal position</span>
                <span class="n">pos2</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx_char</span> <span class="o">-</span> <span class="n">pos2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># flip the horizontal position</span>
            <span class="k">if</span> <span class="n">vertically</span><span class="p">:</span>
                <span class="n">pos1</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">idx_lines</span> <span class="o">-</span> <span class="n">pos1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># flip the vertical position</span>
                <span class="n">pos2</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">idx_lines</span> <span class="o">-</span> <span class="n">pos2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># flip the vertical position</span>
            <span class="n">new_basepair_dict</span><span class="p">[</span><span class="n">Position</span><span class="p">(</span><span class="n">pos1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Position</span><span class="p">(</span><span class="n">pos2</span><span class="p">)</span> 

        <span class="bp">self</span><span class="o">.</span><span class="n">_basepair</span> <span class="o">=</span> <span class="n">new_basepair_dict</span> <span class="c1"># save the new basepair</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">strand</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># flip only the strands in the strand_index list, if it is not None</span>
            <span class="k">if</span> <span class="n">strand_index</span> <span class="ow">and</span> <span class="n">ind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">strand_index</span><span class="p">:</span> 
                <span class="k">continue</span>

            <span class="c1"># flip the start position of the strands: </span>
            <span class="c1"># the new start is the border - the previous position</span>
            <span class="n">new_start</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">strand</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">horizontally</span><span class="p">:</span>
                <span class="n">new_start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx_char</span> <span class="o">-</span> <span class="n">strand</span><span class="o">.</span><span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">vertically</span><span class="p">:</span>
                <span class="n">new_start</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx_lines</span> <span class="o">-</span> <span class="n">strand</span><span class="o">.</span><span class="n">start</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">strand</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">new_start</span>
            <span class="n">strand</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">horizontally</span><span class="p">,</span> <span class="n">vertically</span><span class="p">,</span> <span class="n">flip_start</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> 
        <span class="k">return</span> <span class="bp">self</span></div>


    <span class="nd">@wraps</span><span class="p">(</span><span class="n">fold_bar</span><span class="p">)</span> <span class="c1"># inherit the documentation from the function</span>
    <span class="k">def</span> <span class="nf">folding_barriers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kl_delay</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">150</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">fold_bar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">,</span> <span class="n">kl_delay</span><span class="p">)</span>
    
<div class="viewcode-block" id="Motif.get_strand_index_map">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif.get_strand_index_map">[docs]</a>
    <span class="k">def</span> <span class="nf">get_strand_index_map</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a dictionary of positions as keys and the index of the</span>
<span class="sd">        strand in the motif as values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dict[Tuple[int, int], int]</span>
<span class="sd">            A dictionary mapping positions to strand indexes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">pos</span><span class="p">:</span> <span class="n">ind</span> <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">strand</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">strand</span><span class="o">.</span><span class="n">positions</span><span class="p">}</span></div>

    
<div class="viewcode-block" id="Motif.get_position_map">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif.get_position_map">[docs]</a>
    <span class="k">def</span> <span class="nf">get_position_map</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a dictionary of positions as keys and the corresponding</span>
<span class="sd">        characters as values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Dict[Tuple[int, int], str]</span>
<span class="sd">            A dictionary mapping positions to characters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">pos</span><span class="p">:</span> <span class="n">sym</span> <span class="k">for</span> <span class="n">strand</span> <span class="ow">in</span> <span class="bp">self</span> 
                            <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">sym</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">strand</span><span class="o">.</span><span class="n">positions</span><span class="p">,</span> <span class="n">strand</span><span class="o">.</span><span class="n">strand</span><span class="p">)}</span></div>


<div class="viewcode-block" id="Motif.insert">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif.insert">[docs]</a>
    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
               <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">strand</span><span class="p">:</span> <span class="s1">&#39;Strand&#39;</span><span class="p">,</span> 
               <span class="n">join</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
               <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Motif&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert a strand at a given index in the motif.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int</span>
<span class="sd">            The index at which to insert the strand.</span>
<span class="sd">        strand : Strand</span>
<span class="sd">            The strand to be inserted.</span>
<span class="sd">        join : bool, default True</span>
<span class="sd">            Whether to attempt joining the new strand with existing strands.</span>
<span class="sd">        copy : bool, default False</span>
<span class="sd">            If True, a copy of the strand is inserted.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Motif</span>
<span class="sd">            The updated motif.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `strand` is not a `Strand` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strand</span><span class="p">,</span> <span class="n">Strand</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">strand</span><span class="si">}</span><span class="s2"> is not a Strand object.&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">strand</span> <span class="o">=</span> <span class="n">strand</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">strand</span><span class="o">.</span><span class="n">register_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_updated_strands</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strands</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">strand</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">join</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_strands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">join_strands</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_strands</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock_coords</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_strands_block</span> <span class="o">=</span> <span class="n">StrandsBlock</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strands</span><span class="p">])</span> 

        <span class="bp">self</span><span class="o">.</span><span class="n">_updated_strands</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Motif.pop">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif.pop">[docs]</a>
    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Strand&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove and return the strand at the specified index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, default -1</span>
<span class="sd">            The index of the strand to remove.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Strand</span>
<span class="sd">            The removed strand.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">strand</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strands</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># REMOVE THE PAIRS IN WHICH THE STRAND IS INVOLVED</span>
        <span class="n">new_basepair</span> <span class="o">=</span> <span class="n">BasePair</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basepair</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">strand</span><span class="o">.</span><span class="n">positions</span> <span class="ow">or</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">strand</span><span class="o">.</span><span class="n">positions</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">new_basepair</span><span class="p">[</span><span class="n">Position</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Position</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_basepair</span> <span class="o">=</span> <span class="n">new_basepair</span>
        <span class="n">strand</span><span class="o">.</span><span class="n">_clear_callbacks</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updated_strands</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updated_basepair</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock_coords</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_strands_block</span> <span class="o">=</span> <span class="n">StrandsBlock</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strands</span><span class="p">])</span> 

        <span class="k">return</span> <span class="n">strand</span></div>


<div class="viewcode-block" id="Motif.replace_all_strands">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif.replace_all_strands">[docs]</a>
    <span class="k">def</span> <span class="nf">replace_all_strands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                            <span class="n">strands</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s1">&#39;Strand&#39;</span><span class="p">],</span>
                            <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                            <span class="n">join</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Motif&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace all the strands in the motif with the provided list of strands.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strands : List[Strand]</span>
<span class="sd">            The list of strands to replace the current strands.</span>
<span class="sd">        copy : bool, default True</span>
<span class="sd">            If True, the strands are copied before replacing the current strands.</span>
<span class="sd">        join : bool, default False</span>
<span class="sd">            Whether to attempt joining the new strands.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Motif</span>
<span class="sd">            The updated motif.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any of the provided strands is not a `Strand` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># copy the strands if needed, registart callbacks</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">new_strands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_strands_preserve_blocks</span><span class="p">(</span><span class="n">strands</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_strands</span> <span class="o">=</span> <span class="n">strands</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strands</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Strand</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2"> is not a Strand object.&quot;</span><span class="p">)</span>
                <span class="n">s</span><span class="o">.</span><span class="n">register_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_updated_strands</span><span class="p">)</span>

        <span class="c1"># join the strands if needed</span>
        <span class="k">if</span> <span class="n">join</span><span class="p">:</span>
            <span class="n">new_strands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">join_strands</span><span class="p">(</span><span class="n">new_strands</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_strands</span> <span class="o">=</span> <span class="n">new_strands</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock_coords</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_strands_block</span> <span class="o">=</span> <span class="n">StrandsBlock</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strands</span><span class="p">])</span>

        <span class="c1"># this will also update the basepair dictionary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updated_strands</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Motif.rotate">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif.rotate">[docs]</a>
    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Motif&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotate the motif 90 degrees clockwise.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        times : int, default 1</span>
<span class="sd">            The number of times to rotate the motif.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Motif</span>
<span class="sd">            The rotated motif.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">times</span><span class="o">%</span><span class="mi">4</span><span class="p">):</span> 
            <span class="c1"># collect the num_lines before is updated</span>
            <span class="n">num_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_lines</span>

            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="o">+</span><span class="mi">1</span>
                <span class="c1"># when rotating from vertical to horizontal: change sign</span>
                <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">_direction</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> 
                    <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">s</span><span class="o">.</span><span class="n">_start</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">_start</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">num_lines</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">start</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> 
                                            <span class="n">y</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">s</span><span class="o">.</span><span class="n">_direction</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">_direction</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">sign</span> <span class="o">*</span> <span class="n">s</span><span class="o">.</span><span class="n">_direction</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> 
                                                    <span class="n">y</span><span class="o">=</span><span class="n">sign</span> <span class="o">*</span> <span class="n">s</span><span class="o">.</span><span class="n">_direction</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> 
                <span class="c1"># adjust the sequence symbols</span>
                <span class="n">s</span><span class="o">.</span><span class="n">strand</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">strand</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">rotate_90</span><span class="p">)</span>   

            <span class="c1"># rotate the basepair dictionary</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autopairing</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basepair</span><span class="p">:</span>
                <span class="n">new_bp</span> <span class="o">=</span> <span class="n">BasePair</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basepair</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">new_k</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_lines</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">new_v</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_lines</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">new_bp</span><span class="p">[</span><span class="n">Position</span><span class="p">(</span><span class="n">new_k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Position</span><span class="p">(</span><span class="n">new_v</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_basepair</span> <span class="o">=</span> <span class="n">new_bp</span>

        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Motif.save_3d_model">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif.save_3d_model">[docs]</a>
    <span class="k">def</span> <span class="nf">save_3d_model</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;Motif&quot;</span><span class="p">,</span> <span class="s2">&quot;Origami&quot;</span><span class="p">],</span>
                      <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;motif&#39;</span><span class="p">,</span> 
                      <span class="n">config</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                      <span class="n">topology</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                      <span class="n">forces</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                      <span class="n">pk_forces</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                      <span class="n">return_text</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                      <span class="n">sequence</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">pdb</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                      <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the motif 3D structure in a file for structural 3D modeling.</span>
<span class="sd">        This function save the 3D oxDNA motif representation in conformation and </span>
<span class="sd">        topology xoDNA-format files, and optionally in PDB format.</span>
<span class="sd">        It can also save additional force constraints for oxDNA simulation</span>
<span class="sd">        and protein configurations if specified.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str, optional, default=&quot;motif&quot;</span>
<span class="sd">            The base filepath for the generated oxDNA files (without extension).</span>
<span class="sd">        config : bool, default=True</span>
<span class="sd">            If True, generates a configuration (.dat) file with nucleotide positions.</span>
<span class="sd">        topology : bool, default=True</span>
<span class="sd">            If True, generates a topology (.top) file specifying strand connectivity.</span>
<span class="sd">        forces : bool, default=False</span>
<span class="sd">            If True, saves force constraints for base-pair interactions.</span>
<span class="sd">        pk_forces : bool, default=False</span>
<span class="sd">            If True, saves force constraints specifically for pseudoknots.</span>
<span class="sd">        return_text : bool, default=False</span>
<span class="sd">            If True, returns the generated oxDNA configuration and topology as strings</span>
<span class="sd">            instead of writing to files (used for real-time visualization).</span>
<span class="sd">        sequence : str, optional</span>
<span class="sd">            If provided, uses the given sequence to generate the topology.</span>
<span class="sd">        pdb : bool, optional, default=False</span>
<span class="sd">            If True, exports a PDB (Protein Data Bank) file for visualization.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments for customizing force constraints </span>
<span class="sd">            and PDB export settings.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Optional[Tuple[str, str]]</span>
<span class="sd">            If `return_text` is True, returns a tuple containing:</span>
<span class="sd">            - The configuration file content as a string.</span>
<span class="sd">            - The topology file content as a string.</span>
<span class="sd">            Otherwise, returns None.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function requires the oxDNA analysis tools package to be installed</span>
<span class="sd">        for the generation of force constraints and pdb export.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">get_kwargs_names</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="c1"># Extract parameters that have default values (kwargs)</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> 
                      <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="o">!=</span> <span class="n">param</span><span class="o">.</span><span class="n">empty</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">kwargs</span>

         <span class="c1"># remove the extension from the filename</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">strands</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">sequence</span><span class="p">]</span>
        <span class="n">n_nucleotides</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">sequence</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strands</span><span class="p">])</span>
        <span class="n">n_strands</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strands</span><span class="p">)</span>
    
        <span class="c1"># create the conformation and topology text</span>
        <span class="n">conf_text</span> <span class="o">=</span> <span class="s1">&#39;t = 0</span><span class="se">\n</span><span class="s1">b = 1000 1000 1000</span><span class="se">\n</span><span class="s1">E = 0 0 0</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">topology_text</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="c1">### ADD THE STRANDS TO THE CONFORMATION AND TOPOLOGY TEXTS ###</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strands</span><span class="p">:</span>
            <span class="c1"># check for the sequence direction</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">directionality</span> <span class="o">==</span> <span class="s1">&#39;53&#39;</span><span class="p">:</span>
                <span class="n">seq</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">sequence</span><span class="p">)</span>
                <span class="n">coord_array</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">array</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">seq</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">sequence</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">coord_array</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># add the coordinates to the conformations text</span>
            <span class="k">if</span> <span class="n">config</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a3</span> <span class="ow">in</span> <span class="n">coord_array</span><span class="p">:</span>
                    <span class="n">conf_text</span> <span class="o">+=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">a1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">a1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">a1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">a3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">a3</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">a3</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                 <span class="p">)</span>

            <span class="c1"># add the sequence to the topology text</span>
            <span class="k">if</span> <span class="n">topology</span><span class="p">:</span>
                <span class="n">topology_text</span> <span class="o">+=</span> <span class="n">seq</span> <span class="o">+</span> <span class="s1">&#39; type=RNA circular=false </span><span class="se">\n</span><span class="s1">&#39;</span>

            <span class="c1"># add the proteins to the conformation text</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">protein</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">proteins</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">config</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a3</span> <span class="ow">in</span> <span class="n">protein</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                            <span class="n">conf_text</span> <span class="o">+=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span>
                                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">a1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">a1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">a1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span>
                                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">a3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">a3</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">a3</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                        <span class="p">)</span>
                    
                    <span class="c1"># add the proteins to the topology text</span>
                    <span class="k">if</span> <span class="n">topology</span><span class="p">:</span>
                        <span class="n">topology_text</span> <span class="o">+=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">protein</span><span class="o">.</span><span class="n">sequence</span><span class="si">}</span><span class="s2"> &quot;</span>
                                          <span class="s2">&quot;type=peptide circular=false </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                        
                    <span class="n">n_nucleotides</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">protein</span><span class="p">)</span>
                    <span class="n">n_strands</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Problem with proteins&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sequence</span><span class="p">:</span>
            <span class="n">topology_text</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">seq</span><span class="si">}</span><span class="s1"> type=RNA circular=false&#39;</span> 
                                            <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">sequence</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)])</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
            
        <span class="n">topology_text</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">n_nucleotides</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">n_strands</span><span class="si">}</span><span class="s1"> 5-&gt;3</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">topology_text</span>

        <span class="k">if</span> <span class="n">return_text</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">conf_text</span><span class="p">,</span> <span class="n">topology_text</span>

        <span class="c1"># save the files</span>
        <span class="n">conf_file</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s1">.dat&#39;</span>
        <span class="k">if</span> <span class="n">config</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">conf_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">conf_text</span><span class="p">)</span>
        <span class="n">top_file</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s1">.top&#39;</span>
        <span class="k">if</span> <span class="n">topology</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">top_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">topology_text</span><span class="p">)</span>

        <span class="c1">### save the external forces</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">forces</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pk_forces</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">oat_installed</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;oxDNA_analysis_tools is not installed. &quot;</span>
                          <span class="s2">&quot;Skipping force writing.&quot;</span><span class="p">,</span> 
                          <span class="ne">UserWarning</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">trap_kw_names</span> <span class="o">=</span> <span class="n">get_kwargs_names</span><span class="p">(</span><span class="n">mutual_trap</span><span class="p">)</span>
            <span class="n">trap_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">trap_kw_names</span><span class="p">}</span>
            <span class="n">pair_map</span> <span class="o">=</span> <span class="n">dot_bracket_to_pair_map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>
            <span class="n">trap_kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;stiff&#39;</span><span class="p">,</span> <span class="mf">0.09</span><span class="p">)</span>
            <span class="n">trap_kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;r0&#39;</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)</span>
            <span class="n">trap_kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;PBC&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">trap_kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;rate&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">trap_kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;stiff_rate&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">force_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">pk_force_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">ss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> 
            <span class="k">for</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">pair_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">n2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">trap1</span> <span class="o">=</span> <span class="n">mutual_trap</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="o">**</span><span class="n">trap_kwargs</span><span class="p">)</span>
                <span class="n">trap2</span> <span class="o">=</span> <span class="n">mutual_trap</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="o">**</span><span class="n">trap_kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">forces</span><span class="p">:</span>
                    <span class="n">force_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trap1</span><span class="p">)</span>
                    <span class="n">force_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trap2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pk_forces</span> <span class="ow">and</span> <span class="n">ss</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39;.()&#39;</span><span class="p">:</span>
                    <span class="n">pk_force_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trap1</span><span class="p">)</span>
                    <span class="n">pk_force_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trap2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">forces</span><span class="p">:</span>
                <span class="n">write_force_file</span><span class="p">(</span><span class="n">force_list</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s1">_forces.txt&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pk_forces</span><span class="p">:</span>
                <span class="n">write_force_file</span><span class="p">(</span><span class="n">pk_force_list</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s1">_pk_forces.txt&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pdb</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">oat_installed</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;oxDNA_analysis_tools is not installed. &quot;</span>
                              <span class="s2">&quot;Skipping PDB export.&quot;</span><span class="p">,</span> 
                              <span class="ne">UserWarning</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Read oxDNA configuration</span>
                <span class="n">system</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">strand_describe</span><span class="p">(</span><span class="n">top_file</span><span class="p">)</span>
                <span class="n">ti</span><span class="p">,</span> <span class="n">di</span> <span class="o">=</span> <span class="n">describe</span><span class="p">(</span><span class="n">top_file</span><span class="p">,</span> <span class="n">conf_file</span><span class="p">)</span>
                <span class="n">conf</span> <span class="o">=</span> <span class="n">get_confs</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span> <span class="n">di</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">conf</span> <span class="o">=</span> <span class="n">inbox</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1"># remove the proteins from the configuration if no pdb files provided</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;protein_pdb_files&#39;</span><span class="p">):</span>
                    <span class="n">strand_offset</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">to_pop</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">conf_to_keep</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">strand</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">strands</span><span class="p">):</span>
                        <span class="n">strand_end</span> <span class="o">=</span> <span class="n">strand_offset</span> <span class="o">+</span> <span class="n">strand</span><span class="o">.</span><span class="n">get_length</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">strand</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;peptide&#39;</span><span class="p">:</span>
                            <span class="n">to_pop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">conf_to_keep</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">strand_offset</span><span class="p">,</span> <span class="n">strand_end</span><span class="p">))</span>
                        <span class="n">strand_offset</span> <span class="o">=</span> <span class="n">strand_end</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">to_pop</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">system</span><span class="o">.</span><span class="n">strands</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

                <span class="n">oxdna_pdb_kw_names</span> <span class="o">=</span> <span class="n">get_kwargs_names</span><span class="p">(</span><span class="n">oxDNA_PDB</span><span class="p">)</span>
                <span class="n">oxdna_pdb_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> 
                                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">oxdna_pdb_kw_names</span><span class="p">}</span>
                <span class="n">oxdna_pdb_kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;uniform_residue_names&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">oxDNA_PDB</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="n">system</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">oxdna_pdb_kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Motif.save_fasta">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif.save_fasta">[docs]</a>
    <span class="k">def</span> <span class="nf">save_fasta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;motif&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the motif sequences in a FASTA file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str, optional</span>
<span class="sd">            The filepath to save (without extension). Default is &#39;motif&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">seqs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)</span>
        <span class="n">dotb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s1">.fasta&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">seq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">seqs</span><span class="p">):</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&gt;strand_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">seq</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dotb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Motif.save_text">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif.save_text">[docs]</a>
    <span class="k">def</span> <span class="nf">save_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;motif&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the motif representation as a text file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename_path : str, optional</span>
<span class="sd">            The filepath to save (without extension). Default is &#39;motif&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">filename_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s1">.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&gt;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>


<div class="viewcode-block" id="Motif.shift">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif.shift">[docs]</a>
    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
              <span class="n">shift_vect</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> 
              <span class="n">extend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Motif&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shift the motif of the given shift vector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shift_vect : Tuple[int, int]</span>
<span class="sd">            The (x, y) shift values.</span>
<span class="sd">        extend : bool, default False</span>
<span class="sd">            Whether to extend junctions when shifting</span>
<span class="sd">            (in the direction opposite to the shifting direction).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Motif</span>
<span class="sd">            The shifted motif.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If shifting moves strands to negative positions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Strand</span><span class="o">.</span><span class="n">_check_position</span><span class="p">(</span><span class="n">input_pos_dir</span> <span class="o">=</span> <span class="n">shift_vect</span><span class="p">)</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">Position</span><span class="p">(</span><span class="n">shift_vect</span><span class="p">)</span>
        <span class="n">min_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_pos</span>
        <span class="c1"># check if the shift will bring the strands to negative positions</span>
        <span class="k">if</span> <span class="n">min_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">min_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MotifStructureError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;The motif cannot be shifed. The strands cannot be drawn&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot; at negative positons. Attempt to draw the motif at &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;position (</span><span class="si">{</span><span class="n">min_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">shift_vect</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">min_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">shift_vect</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                        
        
        <span class="c1"># take the junctions in the opposite direction of the shift</span>
        <span class="n">junc_vert</span><span class="p">,</span> <span class="n">junc_hor</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">extend</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">junc_vert</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">junctions</span><span class="p">[</span><span class="n">Position</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> 
                                                     <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">copysign</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">]))))]</span>
            <span class="k">if</span> <span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">junc_hor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">junctions</span><span class="p">[</span><span class="n">Position</span><span class="p">((</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">copysign</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span>
                                                    <span class="mi">0</span><span class="p">))]</span> 
                
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">extend_strand</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1">### CREATE EXTENSION STRANDS FOR THE JUNCTIONS ###</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">junc_vert</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">positions</span><span class="p">:</span>
                    <span class="n">extend_strand</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Strand</span><span class="p">(</span><span class="s1">&#39;â”‚&#39;</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> 
                                                <span class="n">start</span><span class="o">=</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                                                       <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> 
                                                <span class="n">direction</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> 
                                                           <span class="nb">int</span><span class="p">(</span><span class="n">copysign</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> 
                                                                        <span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">])))))</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">junc_hor</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">positions</span><span class="p">:</span> 
                    <span class="n">extend_strand</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Strand</span><span class="p">(</span><span class="s1">&#39;â”€&#39;</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> 
                                                <span class="n">start</span><span class="o">=</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                                                       <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                                <span class="n">direction</span><span class="o">=</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">copysign</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> 
                                                                        <span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> 
                                                           <span class="mi">0</span><span class="p">)))</span>
            
            <span class="c1"># for each strand shift the starting position</span>
            <span class="n">s</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1">#loop through the strands forming the extensions</span>
            <span class="k">for</span> <span class="n">s2</span> <span class="ow">in</span> <span class="n">extend_strand</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="c1"># join the strand to the vertical extension</span>
            
        <span class="c1"># shift every basepair too</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autopairing</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_basepair</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basepair</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Motif.sort">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif.sort">[docs]</a>
    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
             <span class="n">key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="s1">&#39;Strand&#39;</span><span class="p">],</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Motif&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort the strands in the motif.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : function, optional</span>
<span class="sd">            The function to use to sort the strands.</span>
<span class="sd">            If None, the strands are sorted by: </span>
<span class="sd">                - the strands with 5&#39; end</span>
<span class="sd">                - the strand with the lowest y start position</span>
<span class="sd">                - the strand with the lowest x start position.</span>
<span class="sd">        reverse : bool, default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Motif</span>
<span class="sd">            The motif with the sorted strands.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span><span class="p">:</span>
            <span class="c1"># sort the strand according to the lowest start position</span>
            <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;5&#39;</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">strand</span><span class="p">),</span> <span class="o">*</span><span class="n">s</span><span class="o">.</span><span class="n">start</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_strands</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Motif.strip">
<a class="viewcode-back" href="../../../../pyfurnace.design.core.html#pyfurnace.design.core.motif.Motif.strip">[docs]</a>
    <span class="k">def</span> <span class="nf">strip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">skip_axis</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Motif&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the empty lines/columns in the motif structure.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        skip_axis: int, optional</span>
<span class="sd">            The numpy axis to skip when stripping the motif </span>
<span class="sd">            (1 for horizontal, 0 for vertical).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Motif</span>
<span class="sd">            The stripped motif.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">min_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_pos</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">min_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">skip_axis</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">),</span> 
                 <span class="o">-</span><span class="n">min_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">skip_axis</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Luca Monari.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>